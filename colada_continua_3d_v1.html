<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Colada Continua 3D - Simulación</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0f1a; color:#eee; font-family:Segoe UI, Roboto, Arial, sans-serif; }
    #scene { position:fixed; inset:0; }
    /* Panel lateral */
    #panel {
      position:fixed; right:20px; top:20px; width:360px; max-height:85vh; overflow:auto;
      background:rgba(0,0,0,0.75); border:2px solid #00d1b2; border-radius:12px; padding:14px; backdrop-filter: blur(8px);
    }
    #panel h2 { margin:8px 0 10px; font-size:18px; color:#00d1b2; }
    .item { display:flex; justify-content:space-between; gap:10px; padding:8px 6px; border-bottom:1px dashed rgba(255,255,255,0.08); }
    .name { color:#fff; font-size:13px; }
    .desc { color:#c2c8d0; font-size:12px; }
    .tag { background:#0e1b2e; border:1px solid #00d1b2; color:#00d1b2; padding:2px 8px; border-radius:999px; font-weight:600; font-size:12px; }
    /* Controles */
    #controls { position:fixed; left:50%; transform:translateX(-50%); bottom:20px; display:flex; gap:12px; background:rgba(0,0,0,0.7); border:2px solid #ffc857; padding:15px 20px; border-radius:10px; }
    button { background:#243b53; color:#fff; border:1px solid #00d1b2; padding:12px 20px; border-radius:8px; cursor:pointer; font-size:16px; font-weight:600; }
    button:hover { filter:brightness(1.1); transform:scale(1.05); transition:all 0.2s; }
    #hud { position:fixed; left:20px; top:20px; background:rgba(0,0,0,0.7); border:2px solid #ffc857; border-radius:12px; padding:12px; min-width:260px; }
    #temp { height:8px; background:#1f2937; border-radius:6px; overflow:hidden; margin-top:6px; }
    #temp span { display:block; height:100%; width:0%; background:linear-gradient(90deg,#ff6b6b,#ffa600,#fffb82); transition:width .3s; }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>
  <div id="hud">
    <div><b>Colada Continua (vertical)</b></div>
    <div>Temp hilo: <span id="tempValue">20°C</span></div>
    <div id="temp"><span id="tempBar"></span></div>
  </div>
  <div id="panel">
    <h2>Equipos Principales</h2>
    <div class="item"><div><div class="name">Horno de Inducción</div><div class="desc">5 t/h · 3500 kW</div></div><div class="tag">ON</div></div>
    <div class="item"><div><div class="name">Sistema de Fundición</div><div class="desc">Crisol refractario</div></div><div class="tag">OK</div></div>
    <div class="item"><div><div class="name">Colada Continua</div><div class="desc">Palanquillas 150×150 mm</div></div><div class="tag">RUN</div></div>
    <div class="item"><div><div class="name">Moldeadora de Bolas</div><div class="desc">Moldeado de bolas de acero</div></div><div class="tag">STBY</div></div>
    <h2>Auxiliares</h2>
    <div class="item"><div><div class="name">Transformador Eléctrico</div><div class="desc">4000 kVA</div></div><div class="tag">OK</div></div>
    <div class="item"><div><div class="name">Sistema de Enfriamiento</div><div class="desc">Torre 500 m³/h</div></div><div class="tag">70%</div></div>
    <div class="item"><div><div class="name">Grúa Puente</div><div class="desc">Cap. 15 t</div></div><div class="tag">AUTO</div></div>
    <div class="item"><div><div class="name">Filtración de Humos</div><div class="desc">Captación y filtrado</div></div><div class="tag">ON</div></div>
    <div class="item"><div><div class="name">Cargador de Chatarra</div><div class="desc">Automatizado</div></div><div class="tag">AUTO</div></div>
    <h2>Control</h2>
    <div class="item"><div><div class="name">PLC + SCADA</div><div class="desc">Control automatizado</div></div><div class="tag">ONLINE</div></div>
    <div class="item"><div><div class="name">Sensores y Medición</div><div class="desc">Temperatura, nivel, flujo</div></div><div class="tag">OK</div></div>
    <div class="item"><div><div class="name">Sistema de Seguridad</div><div class="desc">Alarmas y paradas</div></div><div class="tag">ARM</div></div>
  </div>
  <div id="controls">
    <button id="btnPlay">▶ Iniciar</button>
    <button id="btnPause">⏸ Pausa</button>
    <button id="btnReset">↺ Reiniciar</button>
    <button id="btnIso">⌗ Isométrica</button>
    <button id="btnTop">⬇ Superior</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer; let isRunning=true; let t=0;
    let rollersV=[], rollersH=[], sprays=[], molten, ladle, strand, particles=[], tundishPool;
    let path, pathLen=1, u=0;
    let craneTrolley, craneHook, cranePulley1, cranePulley2, craneHookCable; // Elementos de la grúa
    const params={ speed:0.005 }; // Más lento para ver el proceso

    init(); animate();

    function init(){
      const canvas=document.getElementById('scene');
      renderer=new THREE.WebGLRenderer({canvas, antialias:true});
      renderer.setSize(innerWidth, innerHeight); renderer.setPixelRatio(devicePixelRatio);
      renderer.setClearColor(0x0b0f1a, 1);
      if(!renderer.getContext){ alert('WebGL no soportado en este navegador. Prueba Chrome/Edge/Opera con aceleración de hardware.'); }
      scene=new THREE.Scene(); scene.background=new THREE.Color(0x0b0f1a);

      camera=new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 2000);
      camera.position.set(80,45,110); camera.lookAt(0,10,0);

      // Controles de mouse para rotar
      let isDragging=false, prevMouse={x:0,y:0};
      canvas.addEventListener('mousedown',e=>{isDragging=true; prevMouse={x:e.clientX,y:e.clientY};});
      canvas.addEventListener('mousemove',e=>{
        if(!isDragging)return;
        const dx=e.clientX-prevMouse.x, dy=e.clientY-prevMouse.y;
        const radius=Math.sqrt(camera.position.x**2+camera.position.y**2+camera.position.z**2);
        const theta=Math.atan2(camera.position.z,camera.position.x);
        const phi=Math.acos(camera.position.y/radius);
        const newTheta=theta-dx*0.005, newPhi=Math.max(0.1,Math.min(Math.PI-0.1,phi+dy*0.005));
        camera.position.x=radius*Math.sin(newPhi)*Math.cos(newTheta);
        camera.position.y=radius*Math.cos(newPhi);
        camera.position.z=radius*Math.sin(newPhi)*Math.sin(newTheta);
        camera.lookAt(0,10,0);
        prevMouse={x:e.clientX,y:e.clientY};
      });
      canvas.addEventListener('mouseup',()=>isDragging=false);
      canvas.addEventListener('wheel',e=>{
        e.preventDefault();
        const factor=1+e.deltaY*0.001;
        camera.position.multiplyScalar(factor);
      });

      const amb=new THREE.AmbientLight(0x445566,0.4); scene.add(amb);
      const dir=new THREE.DirectionalLight(0xffffff,1.8); dir.position.set(80,120,90); 
      dir.castShadow=true; dir.shadow.mapSize.width=2048; dir.shadow.mapSize.height=2048;
      dir.shadow.camera.left=-100; dir.shadow.camera.right=100; dir.shadow.camera.top=100; dir.shadow.camera.bottom=-100;
      scene.add(dir);
      const hot=new THREE.PointLight(0xff6600,4,120); hot.position.set(-40,48,0); hot.castShadow=true; scene.add(hot);
      renderer.shadowMap.enabled=true; renderer.shadowMap.type=THREE.PCFSoftShadowMap;

      const grid=new THREE.GridHelper(400, 40, 0x1f3349, 0x0d2033); grid.position.y=-40; scene.add(grid);
      const axes=new THREE.AxesHelper(15); axes.position.set(0,0,0); scene.add(axes);

      buildLadleTundishMold();
      buildCasterPath();
      buildRollersAndSprays();
      buildStrand();
      addColorLegend();

      window.addEventListener('resize', onResize);
      bindUI();
    }

    function addColorLegend(){
      // Leyenda de colores en pantalla (similar al panel de control)
      const legendDiv=document.createElement('div');
      legendDiv.id='colorLegend';
      legendDiv.style.cssText='position:absolute; top:180px; left:20px; background:rgba(0,0,0,0.85); padding:15px; border:3px solid #00d1b2; border-radius:8px; color:#fff; font-family:Arial; font-size:16px; z-index:100;';
      legendDiv.innerHTML=`
        <div style="font-weight:bold; margin-bottom:10px; font-size:18px; color:#00d1b2;">CONVENCIONES DE COLOR</div>
        <div style="display:flex; align-items:center; margin:8px 0;"><div style="width:25px; height:25px; background:#999999; border:2px solid #fff; margin-right:10px;"></div> Ladle (Cucharón)</div>
        <div style="display:flex; align-items:center; margin:8px 0;"><div style="width:25px; height:25px; background:#0099cc; border:2px solid #fff; margin-right:10px;"></div> Tundish AZUL (Distribuidor)</div>
        <div style="display:flex; align-items:center; margin:8px 0;"><div style="width:25px; height:25px; background:#ff3300; border:2px solid #fff; margin-right:10px;"></div> Líquido Fundido</div>
        <div style="display:flex; align-items:center; margin:8px 0;"><div style="width:25px; height:25px; background:#cc6600; border:2px solid #fff; margin-right:10px;"></div> Molde de Cobre</div>
        <div style="display:flex; align-items:center; margin:8px 0;"><div style="width:25px; height:25px; background:#ffdd00; border:2px solid #fff; margin-right:10px;"></div> Grúa Puente</div>
        <div style="display:flex; align-items:center; margin:8px 0;"><div style="width:25px; height:25px; background:#ffffff; border:2px solid #fff; margin-right:10px;"></div> Rodillos Guía</div>
        <div style="display:flex; align-items:center; margin:8px 0;"><div style="width:25px; height:25px; background:#0088ff; border:2px solid #fff; margin-right:10px;"></div> Enfriamiento</div>
      `;
      document.body.appendChild(legendDiv);
    }

    function buildLadleTundishMold(){
      // Ladle GRIS - CON DETALLES según imagen de referencia
      const LADLE_HEIGHT = 70; // MUY ALTO para estar por encima
      const ladleGroup = new THREE.Group();
      
      // Cuerpo principal del ladle
      const cupOuter=new THREE.Mesh(new THREE.CylinderGeometry(7,8,12,16), new THREE.MeshStandardMaterial({color:0x999999, metalness:.8, roughness:.3}));
      cupOuter.castShadow=true; ladleGroup.add(cupOuter);
      
      // Refuerzos horizontales (bandas metálicas)
      for(let i=0; i<3; i++){
        const band=new THREE.Mesh(new THREE.TorusGeometry(7.3+i*0.3, 0.3, 8, 16), new THREE.MeshStandardMaterial({color:0x777777, metalness:0.9}));
        band.position.y = -4 + i*4;
        band.rotation.x = Math.PI/2;
        band.castShadow=true;
        ladleGroup.add(band);
      }
      
      // Tornillos/remaches alrededor del ladle
      for(let ring=0; ring<2; ring++){
        for(let a=0; a<8; a++){
          const angle = a/8 * Math.PI * 2;
          const bolt=new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.4, 6), new THREE.MeshStandardMaterial({color:0x333333, metalness:0.95}));
          bolt.position.set(Math.cos(angle)*7.5, -3+ring*6, Math.sin(angle)*7.5);
          bolt.rotation.z = Math.PI/2;
          bolt.castShadow=true;
          ladleGroup.add(bolt);
        }
      }
      
      // Borde superior reforzado
      const rim=new THREE.Mesh(new THREE.TorusGeometry(7, 0.5, 8, 16), new THREE.MeshStandardMaterial({color:0x888888, metalness:0.9}));
      rim.position.y = 6;
      rim.rotation.x = Math.PI/2;
      rim.castShadow=true;
      ladleGroup.add(rim);
      
      // Pico de vertido FRONTAL (hacia donde vierte)
      const spout=new THREE.Mesh(new THREE.ConeGeometry(1.5, 3, 8), new THREE.MeshStandardMaterial({color:0xaaaaaa, metalness:0.8}));
      spout.position.set(6, 3, 0); // Posición frontal superior
      spout.rotation.z = -Math.PI/3; // Inclinado hacia adelante
      spout.castShadow=true;
      ladleGroup.add(spout);
      
      ladleGroup.position.set(-3, LADLE_HEIGHT, 0);
      ladleGroup.rotation.z = -0.3;
      scene.add(ladleGroup);
      ladle = ladleGroup;
      
      // Asa/gancho ladle MEJORADO (doble barra)
      const hookGroup = new THREE.Group();
      const hookBar1=new THREE.Mesh(new THREE.BoxGeometry(0.5, 6, 0.5), new THREE.MeshStandardMaterial({color:0x666666, metalness:0.9}));
      hookBar1.position.x = -1;
      hookBar1.castShadow=true;
      hookGroup.add(hookBar1);
      
      const hookBar2=new THREE.Mesh(new THREE.BoxGeometry(0.5, 6, 0.5), new THREE.MeshStandardMaterial({color:0x666666, metalness:0.9}));
      hookBar2.position.x = 1;
      hookBar2.castShadow=true;
      hookGroup.add(hookBar2);
      
      const hookTop=new THREE.Mesh(new THREE.BoxGeometry(3, 0.8, 0.8), new THREE.MeshStandardMaterial({color:0x666666, metalness:0.9}));
      hookTop.position.y = 3;
      hookTop.castShadow=true;
      hookGroup.add(hookTop);
      
      hookGroup.position.set(-3, LADLE_HEIGHT+6, 0);
      scene.add(hookGroup);
      
      // Polea superior para ladle CON MÁS DETALLE
      const pulleyGroup = new THREE.Group();
      const pulleyWheel=new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 1.2, 16), new THREE.MeshStandardMaterial({color:0x444444, metalness:0.9}));
      pulleyWheel.rotation.z=Math.PI/2;
      pulleyWheel.castShadow=true;
      pulleyGroup.add(pulleyWheel);
      
      // Ranuras de la polea
      for(let i=0; i<3; i++){
        const groove=new THREE.Mesh(new THREE.TorusGeometry(2.1, 0.1, 6, 16), new THREE.MeshStandardMaterial({color:0x222222}));
        groove.position.x = -0.5 + i*0.5;
        groove.rotation.y = Math.PI/2;
        pulleyGroup.add(groove);
      }
      
      pulleyGroup.position.set(-3, LADLE_HEIGHT+12, 0);
      scene.add(pulleyGroup);
      
      // Cables de la polea (dobles)
      for(let i=-0.3; i<=0.3; i+=0.6){
        const cable=new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 5, 6), new THREE.MeshStandardMaterial({color:0x333333, metalness:0.8}));
        cable.position.set(-3+i, LADLE_HEIGHT+9.5, 0);
        scene.add(cable);
      }
      
      // Chorro líquido desde el ladle al tundish - CAÍDA LARGA Y VISIBLE
      // Posición inicial ajustada para que salga del pico frontal
      const pts=[new THREE.Vector3(2,70,0), new THREE.Vector3(1,60,0), new THREE.Vector3(0,50,0)];
      const curve=new THREE.CatmullRomCurve3(pts);
      const tubeGeo=new THREE.TubeGeometry(curve,24,1.8,12,false);
      molten=new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({color:0xff3300, emissive:0xff5500, emissiveIntensity:5}));
      scene.add(molten);

      // TUNDISH AZUL CYAN - ELEVADO - OPTIMIZADO para mejor rendimiento
      const tundishGroup=new THREE.Group();
      const TUNDISH_HEIGHT = 48; // MÁS ELEVADO (antes 38)
      
      // Pared exterior cilíndrica (hueca) - AZUL CYAN - OPTIMIZADA
      const outerWall=new THREE.Mesh(
        new THREE.CylinderGeometry(10,10,10,20,1,true), 
        new THREE.MeshStandardMaterial({color:0x0099cc, metalness:0.7, roughness:0.4, emissive:0x006699, emissiveIntensity:0.4, side:THREE.DoubleSide})
      );
      outerWall.position.y=TUNDISH_HEIGHT; outerWall.castShadow=true; outerWall.receiveShadow=true; tundishGroup.add(outerWall);
      
      // Pared interior (para dar grosor) - AZUL - OPTIMIZADA
      const innerWall=new THREE.Mesh(
        new THREE.CylinderGeometry(9,9,10,20,1,true), 
        new THREE.MeshStandardMaterial({color:0x0088bb, metalness:0.7, roughness:0.5, side:THREE.DoubleSide})
      );
      innerWall.position.y=TUNDISH_HEIGHT; tundishGroup.add(innerWall);
      
      // Base sólida del tundish - AZUL - OPTIMIZADA
      const tundishBase=new THREE.Mesh(
        new THREE.CylinderGeometry(9,10,1,20), 
        new THREE.MeshStandardMaterial({color:0x0099cc, metalness:0.8, roughness:0.5})
      );
      tundishBase.position.y=TUNDISH_HEIGHT-5; tundishBase.receiveShadow=true; tundishGroup.add(tundishBase);
      
      scene.add(tundishGroup);
      
      // Anillos reforzadores externos - AZUL OSCURO - OPTIMIZADOS
      for(let i=0;i<2;i++){
        const ring=new THREE.Mesh(new THREE.TorusGeometry(10.5,0.4,8,20), new THREE.MeshStandardMaterial({color:0x005588, metalness:0.9}));
        ring.position.set(0,TUNDISH_HEIGHT-3+i*5,0); ring.rotation.x=Math.PI/2; ring.castShadow=false; scene.add(ring);
      }
      
      // LÍQUIDO FUNDIDO ROJO DENTRO (MUY VISIBLE) - OPTIMIZADO
      tundishPool=new THREE.Mesh(
        new THREE.CylinderGeometry(8.8,8.8,0.5,20), 
        new THREE.MeshStandardMaterial({
          color:0xff3300, 
          emissive:0xff4400, 
          emissiveIntensity:3.8, 
          transparent:false, 
          opacity:1
        })
      );
      tundishPool.position.set(0,TUNDISH_HEIGHT-2,0); 
      scene.add(tundishPool);
      // Tornillos en tundish
      for(let a=0;a<8;a++){
        const ang=a/8*Math.PI*2;
        const bolt=new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,0.6,8), new THREE.MeshStandardMaterial({color:0x222222, metalness:0.9}));
        bolt.position.set(Math.cos(ang)*13.5,36,Math.sin(ang)*13.5); bolt.rotation.z=Math.PI/2; bolt.castShadow=true; scene.add(bolt);
      }

      // MOLD (molde de cobre) - DIRECTAMENTE DEBAJO DEL TUNDISH - COLOR CONVENCIÓN: NARANJA #ff6600
      const MOLD_HEIGHT = 36; // Justo debajo del tundish (tundish está en 48)
      const moldOuter=new THREE.Mesh(new THREE.BoxGeometry(14,18,14), new THREE.MeshStandardMaterial({color:0xff6600, metalness:.7, roughness:.3, emissive:0xaa3300, emissiveIntensity:0.7}));
      moldOuter.position.set(0,MOLD_HEIGHT,0); moldOuter.castShadow=true; moldOuter.receiveShadow=true; scene.add(moldOuter);
      
      // Abertura superior del molde (para ver cómo entra el líquido)
      const moldOpening=new THREE.Mesh(new THREE.CylinderGeometry(4,3,3,32), new THREE.MeshStandardMaterial({color:0xff8800, metalness:.8, roughness:.2, emissive:0xcc4400, emissiveIntensity:1}));
      moldOpening.position.set(0,MOLD_HEIGHT+9,0); moldOpening.castShadow=true; scene.add(moldOpening);
      
      // Líneas de refrigeración (color enfriamiento azul claro)
      for(let i=0;i<4;i++){
        const pipe=new THREE.Mesh(new THREE.TorusGeometry(8,0.3,12,24,Math.PI), new THREE.MeshStandardMaterial({color:0x00aaff, emissive:0x0088cc, emissiveIntensity:0.4}));
        pipe.position.set(0,MOLD_HEIGHT-3+i*3,0); pipe.rotation.z=Math.PI/2; scene.add(pipe);
      }
      
      // TRANSFORMADOR visible - COLOR CONVENCIÓN: AZUL #6688ff
      // Posicionado CERCA DEL HORNO DE INDUCCIÓN porque lo alimenta eléctricamente
      const transBox=new THREE.Mesh(new THREE.BoxGeometry(15,18,12), new THREE.MeshStandardMaterial({color:0x6688ff, metalness:0.6, roughness:0.5, emissive:0x3355aa, emissiveIntensity:0.4}));
      transBox.position.set(-60,30,0); transBox.castShadow=true; transBox.receiveShadow=true; scene.add(transBox);
      // Bobinas del transformador (azul más oscuro)
      for(let i=0;i<3;i++){
        const coil=new THREE.Mesh(new THREE.TorusGeometry(4,1.5,16,24), new THREE.MeshStandardMaterial({color:0x4466dd, metalness:0.8, emissive:0x2244aa, emissiveIntensity:0.3}));
        coil.position.set(-60,23+i*6,0); coil.rotation.x=Math.PI/2; coil.castShadow=true; scene.add(coil);
      }
      // Aisladores
      for(let i=0;i<4;i++){
        const insulator=new THREE.Mesh(new THREE.CylinderGeometry(0.8,1.2,4,12), new THREE.MeshStandardMaterial({color:0xaaccff, roughness:0.2}));
        insulator.position.set(-60+(i-1.5)*4,39,0); insulator.castShadow=true; scene.add(insulator);
      }
      
      // Cable eléctrico del transformador al horno (representación visual)
      const powerCable=new THREE.Mesh(
        new THREE.BoxGeometry(15,1,1), 
        new THREE.MeshStandardMaterial({color:0x333333, metalness:0.8})
      );
      powerCable.position.set(-50,38,-5); powerCable.castShadow=true; scene.add(powerCable);
      
      // Estructura industrial: plataforma principal con sombras
      const platMat=new THREE.MeshStandardMaterial({color:0x3a4a5a, metalness:0.6, roughness:0.5});
      const plat1=new THREE.Mesh(new THREE.BoxGeometry(100,2,35), platMat);
      plat1.position.set(-10,46,0); plat1.castShadow=true; plat1.receiveShadow=true; scene.add(plat1);
      // Vigas de soporte bajo plataforma
      for(let x=-50;x<40;x+=15){
        const beam=new THREE.Mesh(new THREE.BoxGeometry(2,10,2), platMat);
        beam.position.set(x,41,15); beam.castShadow=true; scene.add(beam);
      }
      
      // Escalera amarilla detallada con barandillas
      const stairMat=new THREE.MeshStandardMaterial({color:0xffa500, metalness:0.4, roughness:0.5});
      for(let i=0;i<12;i++){
        const step=new THREE.Mesh(new THREE.BoxGeometry(3.5,0.5,10), stairMat);
        step.position.set(-52,8+i*3.2,0); step.castShadow=true; step.receiveShadow=true; scene.add(step);
      }
      // Barandillas dobles
      const rail1=new THREE.Mesh(new THREE.BoxGeometry(0.4,42,0.4), stairMat);
      rail1.position.set(-53.5,28,4.5); rail1.castShadow=true; scene.add(rail1);
      const rail2=new THREE.Mesh(new THREE.BoxGeometry(0.4,42,0.4), stairMat);
      rail2.position.set(-53.5,28,-4.5); rail2.castShadow=true; scene.add(rail2);
      // Travesaños horizontales
      for(let i=0;i<8;i++){
        const cross=new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,9), stairMat);
        cross.position.set(-53.5,12+i*4.5,0); scene.add(cross);
      }
      
      // Barandilla plataforma con postes y travesaños
      for(let x=-55;x<35;x+=6){
        const post=new THREE.Mesh(new THREE.BoxGeometry(0.4,4,0.4), stairMat);
        post.position.set(x,49,16); post.castShadow=true; scene.add(post);
        if(x<28){
          const rail=new THREE.Mesh(new THREE.BoxGeometry(6,0.3,0.3), stairMat);
          rail.position.set(x+3,50.5,16); scene.add(rail);
        }
      }
      
      // Piso/base industrial (como en la imagen)
      const floor1=new THREE.Mesh(new THREE.BoxGeometry(120,3,40), new THREE.MeshStandardMaterial({color:0x5a4a3a, roughness:0.9}));
      floor1.position.set(-10,6,0); floor1.receiveShadow=true; scene.add(floor1);
      const floor2=new THREE.Mesh(new THREE.BoxGeometry(100,3,40), new THREE.MeshStandardMaterial({color:0x4a3a2a, roughness:0.9}));
      floor2.position.set(30,-8,0); floor2.receiveShadow=true; scene.add(floor2);
      
      // PUENTE GRÚA (overhead crane) - MÁS ELEVADO - COLOR CONVENCIÓN: AMARILLO #ffdd00
      const CRANE_BEAM_HEIGHT = 85; // MÁS ALTO (antes 75)
      const craneMat=new THREE.MeshStandardMaterial({color:0xffdd00, metalness:0.7, roughness:0.3, emissive:0xaa8800, emissiveIntensity:0.4});
      // Viga principal (bridge beam)
      const mainBeam=new THREE.Mesh(new THREE.BoxGeometry(120,3,6), craneMat);
      mainBeam.position.set(-10,CRANE_BEAM_HEIGHT,0); mainBeam.castShadow=true; scene.add(mainBeam);
      
      // POLEA 1: En la viga principal (para movimiento del trolley)
      cranePulley1=new THREE.Mesh(new THREE.CylinderGeometry(2,2,1.5,24), new THREE.MeshStandardMaterial({color:0x333333, metalness:0.95, roughness:0.1}));
      cranePulley1.position.set(-10,CRANE_BEAM_HEIGHT+1.5,0); cranePulley1.rotation.x=Math.PI/2; cranePulley1.castShadow=true; scene.add(cranePulley1);
      // Ranuras de la polea 1
      for(let i=0;i<3;i++){
        const groove=new THREE.Mesh(new THREE.TorusGeometry(2.1,0.1,8,24), new THREE.MeshStandardMaterial({color:0x222222}));
        groove.position.set(-10,CRANE_BEAM_HEIGHT+1.5+(i-1)*0.4,0); groove.rotation.x=Math.PI/2; scene.add(groove);
      }
      
      // Vigas laterales de soporte
      const sideBeam1=new THREE.Mesh(new THREE.BoxGeometry(4,4,40), craneMat);
      sideBeam1.position.set(-70,CRANE_BEAM_HEIGHT,0); sideBeam1.castShadow=true; scene.add(sideBeam1);
      const sideBeam2=new THREE.Mesh(new THREE.BoxGeometry(4,4,40), craneMat);
      sideBeam2.position.set(50,CRANE_BEAM_HEIGHT,0); sideBeam2.castShadow=true; scene.add(sideBeam2);
      
      // Columnas de soporte de la grúa - MÁS ALTAS
      for(let x of [-70,50]){
        for(let z of [-18,18]){
          const col=new THREE.Mesh(new THREE.BoxGeometry(3,35,3), new THREE.MeshStandardMaterial({color:0x555555, metalness:0.8}));
          col.position.set(x,CRANE_BEAM_HEIGHT-17.5,z); col.castShadow=true; scene.add(col);
        }
      }
      
      // TROLLEY (Carro) - GRUPO ANIMABLE - MÁS ALTO
      craneTrolley=new THREE.Group();
      const trolleyBody=new THREE.Mesh(new THREE.BoxGeometry(8,4,6), new THREE.MeshStandardMaterial({color:0x3366aa, metalness:0.8, roughness:0.3}));
      trolleyBody.position.y=81; trolleyBody.castShadow=true; craneTrolley.add(trolleyBody);
      
      // POLEA 2: En el trolley (de donde cuelga el cable del gancho)
      cranePulley2=new THREE.Mesh(new THREE.CylinderGeometry(1.5,1.5,1.2,24), new THREE.MeshStandardMaterial({color:0x333333, metalness:0.95, roughness:0.1}));
      cranePulley2.position.y=79; cranePulley2.rotation.x=Math.PI/2; cranePulley2.castShadow=true; craneTrolley.add(cranePulley2);
      // Ranuras de la polea 2
      for(let i=0;i<3;i++){
        const groove=new THREE.Mesh(new THREE.TorusGeometry(1.6,0.08,8,24), new THREE.MeshStandardMaterial({color:0x222222}));
        groove.position.y=79+(i-1)*0.3; groove.rotation.x=Math.PI/2; craneTrolley.add(groove);
      }
      
      // Motor del trolley
      const motor=new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshStandardMaterial({color:0x555555, metalness:0.9}));
      motor.position.set(0,83,0); motor.castShadow=true; craneTrolley.add(motor);
      
      craneTrolley.position.set(-40,0,0); scene.add(craneTrolley);
      
      // CABLE del gancho (actualizable dinámicamente) - MÁS ALTO
      craneHookCable=new THREE.Mesh(new THREE.CylinderGeometry(0.25,0.25,10,12), new THREE.MeshStandardMaterial({color:0x1a1a1a, metalness:0.9}));
      craneHookCable.position.set(-40,74,0); scene.add(craneHookCable);
      
      // GANCHO - GRUPO ANIMABLE - MÁS ALTO
      craneHook=new THREE.Group();
      const hookBlock=new THREE.Mesh(new THREE.BoxGeometry(2.5,2.5,2.5), new THREE.MeshStandardMaterial({color:0x888888, metalness:0.9, roughness:0.2}));
      hookBlock.castShadow=true; craneHook.add(hookBlock);
      
      const hookShape=new THREE.Mesh(new THREE.TorusGeometry(2,0.5,12,16,Math.PI), new THREE.MeshStandardMaterial({color:0x666666, metalness:0.9}));
      hookShape.position.y=-1.5; hookShape.rotation.x=Math.PI/2; hookShape.castShadow=true; craneHook.add(hookShape);
      
      craneHook.position.set(-40,69,0); scene.add(craneHook);
      
      // Luces de seguridad en la grúa - MÁS ALTAS
      const craneLight1=new THREE.Mesh(new THREE.SphereGeometry(0.6,12,12), new THREE.MeshStandardMaterial({color:0xff0000, emissive:0xff0000, emissiveIntensity:2}));
      craneLight1.position.set(-70,CRANE_BEAM_HEIGHT+1.5,0); scene.add(craneLight1);
      const craneLight2=new THREE.Mesh(new THREE.SphereGeometry(0.6,12,12), new THREE.MeshStandardMaterial({color:0xff0000, emissive:0xff0000, emissiveIntensity:2}));
      craneLight2.position.set(50,CRANE_BEAM_HEIGHT+1.5,0); scene.add(craneLight2);
    }

    function buildCasterPath(){
      // Path: vertical down desde el molde elevado, CURVA MÁS PRONUNCIADA, luego horizontal
      const pts=[ 
        new THREE.Vector3(0,35,0),    // Sale del molde
        new THREE.Vector3(0,25,0),    // Baja vertical
        new THREE.Vector3(0,15,0),    // Continúa vertical
        new THREE.Vector3(0,8,0),     // Final vertical
        new THREE.Vector3(3,3,0),     // INICIO DE CURVA
        new THREE.Vector3(8,-2,0),    // MITAD DE CURVA (más pronunciada)
        new THREE.Vector3(15,-5,0),   // FIN DE CURVA - ya horizontal
        new THREE.Vector3(40,-5,0),   // Horizontal
        new THREE.Vector3(80,-5,0)    // Salida
      ];
      path=new THREE.CatmullRomCurve3(pts);
      pathLen=path.getLength();
    }

    function buildRollersAndSprays(){
      // RODILLOS - COLOR CONVENCIÓN: GRIS #888888
      const rMat=new THREE.MeshStandardMaterial({color:0x888888, metalness:0.9, roughness:0.3, emissive:0x444444, emissiveIntensity:0.2});
      // vertical rollers near the mold - OPTIMIZADO Y AJUSTADO
      for(let y=33;y>=10;y-=5){ 
        const r=new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,10,12), rMat); 
        r.rotation.x=Math.PI/2; r.position.set(0,y,0); r.castShadow=true; r.receiveShadow=true; rollersV.push(r); scene.add(r);
      }
      // Rodillos en la ZONA DE CURVA (importantes para ver el proceso)
      const curveRollerPositions = [
        {x:0, y:8}, {x:2, y:5}, {x:4, y:2}, {x:6, y:0}, {x:9, y:-2}, {x:12, y:-4}
      ];
      curveRollerPositions.forEach(pos => {
        const r=new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,10,12), rMat);
        r.position.set(pos.x, pos.y, 0); 
        const angle = Math.atan2(pos.y, pos.x);
        r.rotation.z=angle + Math.PI/2; 
        r.castShadow=true; rollersV.push(r); scene.add(r);
      });
      // horizontal rollers along x - OPTIMIZADO
      for(let x=16;x<=80;x+=8){ 
        const r=new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,10,12), rMat); 
        r.rotation.z=Math.PI/2; r.position.set(x,-5,0); r.castShadow=true; r.receiveShadow=true; rollersH.push(r); scene.add(r);
      }    

      // SPRAY RINGS - COLOR CONVENCIÓN: AZUL CLARO #00aaff (enfriamiento)
      for(let y=18;y>=2;y-=4){
        const ring=new THREE.Mesh(new THREE.TorusGeometry(7, 0.6, 16, 32), new THREE.MeshStandardMaterial({color:0x00aaff, emissive:0x0088dd, emissiveIntensity:0.9, metalness:0.9}));
        ring.rotation.x=Math.PI/2; ring.position.set(0,y,0); ring.castShadow=true; scene.add(ring);
        sprays.push(ring);
        // Tuberías de conexión (mismo color enfriamiento)
        for(let a=0;a<4;a++){
          const ang=a/4*Math.PI*2;
          const pipe=new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,3,12), new THREE.MeshStandardMaterial({color:0x0099ee, emissive:0x0077bb, emissiveIntensity:0.3}));
          pipe.position.set(Math.cos(ang)*8,y,Math.sin(ang)*8); pipe.rotation.z=Math.PI/2; scene.add(pipe);
        }
      }
      
      // Marco estructural vertical
      const frameMat=new THREE.MeshStandardMaterial({color:0x2a3a4a, metalness:0.7, roughness:0.4});
      for(let z=-8;z<=8;z+=16){
        const beam=new THREE.Mesh(new THREE.BoxGeometry(2,40,2), frameMat);
        beam.position.set(0,10,z); beam.castShadow=true; scene.add(beam);
      }
    }

    function buildStrand(){
      // Palanquilla MÁS GRANDE y MÁS BRILLANTE para verla mejor
      const mat=new THREE.MeshStandardMaterial({color:0xff5533, emissive:0xff3300, emissiveIntensity:2.5, metalness:0.8, roughness:0.2});
      strand=new THREE.Mesh(new THREE.BoxGeometry(7,10,7), mat); 
      strand.castShadow=true; strand.receiveShadow=true;
      scene.add(strand); u=0; t=0;
    }

    function animate(){ requestAnimationFrame(animate); if(isRunning){ t+=0.016; update(); } renderer.render(scene,camera); }

    function update(){
      // advance along path
      u = (u + params.speed) % 1; const pt=path.getPointAt(u), tg=path.getTangentAt(u);
      strand.position.copy(pt);
      const axis=new THREE.Vector3(); axis.crossVectors(new THREE.Vector3(0,1,0), tg).normalize();
      const angle=Math.acos(new THREE.Vector3(0,1,0).dot(tg));
      strand.setRotationFromAxisAngle(axis, angle);
      // cooling
      const cool=u; const hot=1-cool; const emiss=0.2+1.2*hot; strand.material.emissiveIntensity=emiss; strand.material.color.setHSL(0.03+0.06*hot,1,0.45);
      const temp=Math.round(200+1000*hot); document.getElementById('tempValue').textContent=temp+"°C"; document.getElementById('tempBar').style.width=(temp/1200*100)+"%";
      // sprays flicker - SIMPLIFICADO
      if(t%2<0.1){ // Solo actualizar cada 2 segundos
        sprays.forEach(s=>{ s.material.emissiveIntensity = 0.8; });
      }
      // ANIMACIÓN CONTINUA DE LA GRÚA Y LADLE - PROCESO SE REPITE CONSTANTEMENTE
      if(craneTrolley && craneHook && ladle){
        // Ciclo de vertido: 0 a 1 (se repite infinitamente cada 15 segundos para proceso continuo)
        const cycle = (t*0.07) % 1; // Más rápido para que se vea continuo
        
        let trolleyX, hookY, pourAngle;
        
        if(cycle < 0.25){ // Fase 1: Moverse hacia el tundish (25% del tiempo)
          const progress = cycle / 0.25;
          trolleyX = -20 + progress * 17; // Se mueve de -20 a -3
          hookY = 75 - progress * 5; // Baja de 75 a 70
          pourAngle = -0.2; // Posición casi vertical
        }
        else if(cycle < 0.65){ // Fase 2: VERTER sobre el tundish (40% del tiempo) - MÁS TIEMPO VERTIENDO
          trolleyX = -3; // CASI ENCIMA del tundish (X=0)
          hookY = 70; // Altura fija - POR ENCIMA del tundish
          // Inclinación progresiva como una jarra vertiendo
          const pourProgress = (cycle - 0.25) / 0.4;
          pourAngle = -0.2 - pourProgress * 1.2; // Se inclina hasta -1.4 radianes
        }
        else{ // Fase 3: Regresar a posición inicial (35% del tiempo)
          const progress = (cycle - 0.65) / 0.35;
          trolleyX = -3 - progress * 17; // Regresa de -3 a -20
          hookY = 70 + progress * 5; // Sube de 70 a 75
          pourAngle = -1.4 + progress * 1.2; // Regresa a vertical
        }
        
        // Aplicar posiciones
        craneTrolley.position.x = trolleyX;
        craneHook.position.x = trolleyX;
        craneHook.position.y = hookY;
        
        // Actualizar cable del gancho - AJUSTADO PARA ALTURA ELEVADA
        if(craneHookCable){
          const cableLength = 81 - hookY; // Distancia desde trolley hasta gancho
          craneHookCable.scale.y = cableLength/10;
          craneHookCable.position.x = trolleyX;
          craneHookCable.position.y = hookY + cableLength/2;
        }
        
        // El ladle sigue al gancho - MUY POR ENCIMA del tundish
        ladle.position.x = craneHook.position.x;
        ladle.position.y = craneHook.position.y - 5; // Ladle cuelga del gancho
        ladle.rotation.z = pourAngle;
        
        // Rotación de las poleas
        if(cranePulley1) cranePulley1.rotation.y = t*2;
        if(cranePulley2) cranePulley2.rotation.y = t*2;
        
        // Variable global para saber si está vertiendo (usada por partículas) - PROCESO CONTINUO
        window.isPouring = (cycle >= 0.25 && cycle < 0.65); // 40% del ciclo vertiendo constantemente
      }
      
      // Actualizar visibilidad y posición del chorro de fundido - CAÍDA LARGA Y VISIBLE
      if(molten && ladle){
        // Solo mostrar el chorro cuando está vertiendo
        molten.visible = window.isPouring || false;
        if(window.isPouring){
          const ladleX = ladle.position.x;
          const ladleY = ladle.position.y;
          const ladleAngle = ladle.rotation.z;
          // Calcular posición del PICO FRONTAL del ladle (posición relativa 6,3 rotada)
          const spoutLocalX = 6, spoutLocalY = 3;
          const mouthX = ladleX + Math.cos(ladleAngle) * spoutLocalX - Math.sin(ladleAngle) * spoutLocalY;
          const mouthY = ladleY + Math.sin(ladleAngle) * spoutLocalX + Math.cos(ladleAngle) * spoutLocalY;
          // Posicionar el chorro desde el pico frontal hasta el tundish
          molten.position.x = (mouthX + 0)/2; // Centro entre pico y tundish
          molten.position.y = (mouthY + 50)/2; // Centro vertical
          molten.rotation.z = ladleAngle * 0.4; // Más seguimiento del ángulo
          molten.material.emissiveIntensity = 5 + 1.2*Math.sin(t*4); // MÁS BRILLANTE
        }
      }
      
      // Animación del pool del tundish - SIMPLIFICADA para mejor rendimiento
      if(tundishPool){
        // Posición fija (nivel constante)
        tundishPool.position.y=49.5;
        // Escala fija
        tundishPool.scale.set(1, 10, 1);
        // Solo brillo pulsante (sin rotación ni escala dinámica)
        tundishPool.material.emissiveIntensity=3.8+0.6*Math.sin(t*2);
      }
      
      // UNA SOLA PARTÍCULA que se recicla - SÚPER EFICIENTE
      if(window.isPouring && ladle){
        // Crear la partícula única si no existe
        if(particles.length === 0){
          const droplet = new THREE.Mesh(
            new THREE.SphereGeometry(1.5, 8, 8), 
            new THREE.MeshStandardMaterial({color:0xff3300, emissive:0xff5500, emissiveIntensity:4})
          );
          droplet.castShadow = false;
          particles.push(droplet);
          scene.add(droplet);
        }
        
        // Animar la partícula única (reciclar constantemente)
        const droplet = particles[0];
        const ladleX = ladle.position.x;
        const ladleY = ladle.position.y;
        const ladleAngle = ladle.rotation.z;
        // Calcular posición del PICO FRONTAL del ladle (posición relativa 6,3 rotada)
        const spoutLocalX = 6, spoutLocalY = 3;
        const mouthX = ladleX + Math.cos(ladleAngle) * spoutLocalX - Math.sin(ladleAngle) * spoutLocalY;
        const mouthY = ladleY + Math.sin(ladleAngle) * spoutLocalX + Math.cos(ladleAngle) * spoutLocalY;
        
        // Ciclo de caída: reset cuando llega al tundish
        if(!droplet.fallProgress) droplet.fallProgress = 0;
        droplet.fallProgress += 0.05; // Velocidad de caída
        
        if(droplet.fallProgress >= 1){
          droplet.fallProgress = 0; // Reset para caída continua
        }
        
        // Interpolar posición (de ladle a tundish)
        const progress = droplet.fallProgress;
        droplet.position.x = mouthX * (1-progress) + 0 * progress;
        droplet.position.y = mouthY * (1-progress) + 49 * progress;
        droplet.position.z = 0;
        droplet.visible = true;
      } else {
        // Ocultar cuando no está vertiendo
        if(particles.length > 0) particles[0].visible = false;
      }
    }

    function bindUI(){
      document.getElementById('btnPlay').onclick=()=>{ isRunning=true; };
      document.getElementById('btnPause').onclick=()=>{ isRunning=false; };
      document.getElementById('btnReset').onclick=()=>{ isRunning=false; u=0; t=0; };
      document.getElementById('btnIso').onclick=()=>{ camera.position.set(80,45,110); camera.lookAt(0,10,0); };
      document.getElementById('btnTop').onclick=()=>{ camera.position.set(0,160,0.01); camera.lookAt(0,0,0); };
    }

    function onResize(){ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }
  </script>
</body>
</html>

