<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Colada Continua 3D - Simulaci√≥n</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0f1a; color:#eee; font-family:Segoe UI, Roboto, Arial, sans-serif; overflow:hidden; }
    #scene { position:fixed; inset:0; cursor:pointer; }
    
    /* Botones flotantes compactos */
    .float-btn {
      position:fixed; background:rgba(0,0,0,0.85); border:2px solid;
      padding:12px 16px; border-radius:10px; cursor:pointer;
      font-weight:600; font-size:14px; z-index:10;
      transition:all 0.2s; backdrop-filter:blur(8px);
      display:flex; align-items:center; gap:8px;
      box-shadow:0 4px 12px rgba(0,0,0,0.5);
    }
    .float-btn:hover { transform:scale(1.08); box-shadow:0 6px 20px rgba(0,0,0,0.7); }
    
    /* HUD superior izquierdo - compacto */
    #hudBtn { 
      left:20px; top:20px; border-color:#ffc857; color:#ffc857;
    }
    #hudBtn:hover { box-shadow:0 0 20px rgba(255,200,87,0.6); }
    
    /* Bot√≥n de convenciones */
    #legendBtn {
      left:20px; top:80px; border-color:#00d1b2; color:#00d1b2;
    }
    #legendBtn:hover { box-shadow:0 0 20px rgba(0,209,178,0.6); }
    
    /* Bot√≥n de equipos */
    #equipBtn {
      left:20px; top:140px; border-color:#9b59b6; color:#9b59b6;
    }
    #equipBtn:hover { box-shadow:0 0 20px rgba(155,89,182,0.6); }
    
    /* Mini display de temperatura (siempre visible) */
    #tempMini {
      position:fixed; left:200px; top:20px;
      background:rgba(0,0,0,0.85); border:2px solid #ffc857; border-radius:8px;
      padding:8px 12px; font-size:13px; z-index:10; color:#ffc857;
      font-weight:600; backdrop-filter:blur(8px);
    }
    
    /* Modales (ocultos por defecto) */
    .modal-overlay {
      position:fixed; inset:0; background:rgba(0,0,0,0.85);
      z-index:1000; display:none; align-items:center; justify-content:center;
      backdrop-filter:blur(5px);
    }
    .modal-overlay.show { display:flex; animation:fadeIn 0.3s ease-out; }
    @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }
    
    .modal-panel {
      background:rgba(10,15,25,0.98); border:3px solid;
      border-radius:16px; padding:24px; max-width:600px; max-height:85vh;
      overflow-y:auto; box-shadow:0 20px 60px rgba(0,0,0,0.9);
      animation:slideUp 0.3s ease-out;
    }
    @keyframes slideUp { from { opacity:0; transform:translateY(30px); } to { opacity:1; transform:translateY(0); } }
    
    .modal-header {
      display:flex; justify-content:space-between; align-items:center;
      margin-bottom:20px; padding-bottom:12px; border-bottom:2px solid;
    }
    .modal-header h2 { margin:0; font-size:24px; }
    .modal-close {
      background:rgba(255,0,0,0.2); border:2px solid #ff4444;
      color:#ff4444; width:36px; height:36px; border-radius:50%;
      cursor:pointer; font-size:20px; display:flex; align-items:center;
      justify-content:center; transition:all 0.2s; font-weight:bold;
    }
    .modal-close:hover {
      background:#ff4444; color:#fff; transform:rotate(90deg);
    }
    
    /* Estilos para modal de HUD */
    #hudModal .modal-panel { border-color:#ffc857; }
    #hudModal .modal-header { border-color:#ffc857; color:#ffc857; }
    
    /* Estilos para modal de leyenda */
    #legendModal .modal-panel { border-color:#00d1b2; }
    #legendModal .modal-header { border-color:#00d1b2; color:#00d1b2; }
    .legend-item { 
      display:flex; align-items:center; margin:12px 0; padding:10px; 
      border-radius:8px; background:rgba(0,209,178,0.05); transition:all 0.2s;
      cursor:pointer; border:1px solid rgba(0,209,178,0.2);
    }
    .legend-item:hover { background:rgba(0,209,178,0.15); transform:translateX(5px); }
    .legend-color { 
      width:36px; height:36px; border:2px solid #fff; margin-right:14px; 
      border-radius:6px; flex-shrink:0; box-shadow:0 2px 8px rgba(0,0,0,0.4);
    }
    .legend-text { flex:1; }
    .legend-name { color:#fff; font-size:15px; font-weight:600; margin-bottom:3px; }
    .legend-desc { color:#aaa; font-size:12px; }
    
    /* Controles - REPOSICIONADOS */
    #controls { 
      position:fixed; left:50%; transform:translateX(-50%); bottom:20px; 
      display:flex; gap:10px; background:rgba(0,0,0,0.9); 
      border:3px solid #ffc857; padding:14px 18px; border-radius:12px; z-index:10;
      box-shadow:0 4px 20px rgba(255,200,87,0.3);
    }
    button { 
      background:#243b53; color:#fff; border:2px solid #00d1b2; 
      padding:10px 16px; border-radius:8px; cursor:pointer; 
      font-size:15px; font-weight:600; transition:all 0.2s;
    }
    button:hover { filter:brightness(1.2); transform:scale(1.08); box-shadow:0 0 15px rgba(0,209,178,0.5); }
    
    /* Modal de informaci√≥n de elemento (cuando se hace clic en 3D) */
    #infoModal .modal-panel { border-color:#ff6600; }
    #infoModal .modal-header { border-color:#ff6600; color:#ff6600; }
    #infoModal p { margin:12px 0; font-size:14px; line-height:1.7; color:#ddd; }
    #infoModal .info-label { color:#00d1b2; font-weight:600; margin-right:6px; display:inline-block; min-width:120px; }
    
    /* Modal de equipos completo */
    #equipModal .modal-panel { border-color:#9b59b6; max-width:750px; }
    #equipModal .modal-header { border-color:#9b59b6; color:#9b59b6; }
    #equipModal h3 { margin:24px 0 12px; font-size:19px; color:#ffc857; border-bottom:1px solid rgba(255,200,87,0.3); padding-bottom:6px; }
    .equipment-section { 
      margin:14px 0; padding:14px; background:rgba(155,89,182,0.08); 
      border-left:4px solid #9b59b6; border-radius:6px; transition:all 0.2s;
    }
    .equipment-section:hover { background:rgba(155,89,182,0.15); }
    .equipment-name { 
      font-size:16px; font-weight:700; color:#fff; margin-bottom:8px; 
    }
    .equipment-desc { 
      font-size:14px; color:#ccc; line-height:1.8; margin:6px 0; 
    }
    .equipment-tag {
      display:inline-block; background:rgba(155,89,182,0.2); border:1px solid #9b59b6; 
      color:#9b59b6; padding:4px 12px; border-radius:999px; 
      font-weight:600; font-size:11px; margin-top:8px;
    }
    
    /* Scrollbar personalizado */
    ::-webkit-scrollbar { width:8px; }
    ::-webkit-scrollbar-track { background:rgba(0,0,0,0.3); border-radius:4px; }
    ::-webkit-scrollbar-thumb { background:#00d1b2; border-radius:4px; }
    ::-webkit-scrollbar-thumb:hover { background:#00ffcc; }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>
  
  <!-- Botones flotantes compactos -->
  <div id="hudBtn" class="float-btn">
    <span>üå°Ô∏è</span>
    <span>Informaci√≥n</span>
  </div>
  
  <div id="legendBtn" class="float-btn">
    <span>üé®</span>
    <span>Convenciones</span>
  </div>
  
  <div id="equipBtn" class="float-btn">
    <span>‚öôÔ∏è</span>
    <span>Equipos</span>
  </div>
  
  <!-- Mini display de temperatura siempre visible -->
  <div id="tempMini">üå°Ô∏è <span id="tempValue">20¬∞C</span></div>
  
  <!-- MODAL: HUD/Informaci√≥n -->
  <div id="hudModal" class="modal-overlay">
    <div class="modal-panel">
      <div class="modal-header">
        <h2>üå°Ô∏è Informaci√≥n del Proceso</h2>
        <div class="modal-close">√ó</div>
      </div>
      <div style="margin:16px 0;">
        <div style="background:rgba(255,200,87,0.1); padding:16px; border-radius:8px; border-left:4px solid #ffc857;">
          <h3 style="margin:0 0 10px; color:#ffc857; font-size:18px;">Temperatura del Hilo</h3>
          <div style="font-size:32px; font-weight:bold; color:#ffc857; margin:10px 0;">
            <span id="tempValueModal">1180¬∞C</span>
          </div>
          <div style="height:14px; background:#1f2937; border-radius:8px; overflow:hidden; margin-top:12px;">
            <div id="tempBarModal" style="height:100%; width:0%; background:linear-gradient(90deg,#ff6b6b,#ffa600,#fffb82); transition:width .3s;"></div>
          </div>
        </div>
        <div style="margin-top:20px; padding:16px; background:rgba(0,209,178,0.05); border-radius:8px;">
          <h3 style="margin:0 0 10px; color:#00d1b2; font-size:16px;">üìä Estado del Proceso</h3>
          <p style="color:#ddd; line-height:1.8; margin:8px 0;">
            ‚úì <strong>Colada:</strong> Activa<br>
            ‚úì <strong>Velocidad:</strong> 2.5 m/min<br>
            ‚úì <strong>Enfriamiento:</strong> √ìptimo<br>
            ‚úì <strong>Gr√∫a:</strong> En ciclo autom√°tico
          </p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- MODAL: Convenciones de Color -->
  <div id="legendModal" class="modal-overlay">
    <div class="modal-panel">
      <div class="modal-header">
        <h2>üé® Convenciones de Color</h2>
        <div class="modal-close">√ó</div>
      </div>
      <div class="legend-item" data-element="furnace">
        <div class="legend-color" style="background:#aa4444;"></div>
        <div class="legend-text">
          <div class="legend-name">Horno de Inducci√≥n</div>
          <div class="legend-desc">Fundici√≥n electromagn√©tica, rojo incandescente</div>
        </div>
      </div>
      <div class="legend-item" data-element="ladle">
        <div class="legend-color" style="background:#999999;"></div>
        <div class="legend-text">
          <div class="legend-name">Ladle (Cuchar√≥n)</div>
          <div class="legend-desc">Recept√°culo met√°lico para transporte de acero fundido</div>
        </div>
      </div>
      <div class="legend-item" data-element="tundish">
        <div class="legend-color" style="background:#0099cc;"></div>
        <div class="legend-text">
          <div class="legend-name">Tundish (Distribuidor)</div>
          <div class="legend-desc">Recipiente intermedio azul que regula el flujo</div>
        </div>
      </div>
      <div class="legend-item" data-element="molten">
        <div class="legend-color" style="background:#ff3300;"></div>
        <div class="legend-text">
          <div class="legend-name">Acero Fundido</div>
          <div class="legend-desc">L√≠quido brillante a 1500-1600¬∞C</div>
        </div>
      </div>
      <div class="legend-item" data-element="mold">
        <div class="legend-color" style="background:#ff6600;"></div>
        <div class="legend-text">
          <div class="legend-name">Molde de Cobre</div>
          <div class="legend-desc">Molde refrigerado por agua para solidificaci√≥n</div>
        </div>
      </div>
      <div class="legend-item" data-element="crane">
        <div class="legend-color" style="background:#ffdd00;"></div>
        <div class="legend-text">
          <div class="legend-name">Gr√∫a Puente</div>
          <div class="legend-desc">Sistema de transporte a√©reo amarillo</div>
        </div>
      </div>
      <div class="legend-item" data-element="rollers">
        <div class="legend-color" style="background:#888888;"></div>
        <div class="legend-text">
          <div class="legend-name">Rodillos Gu√≠a</div>
          <div class="legend-desc">Sistema de tracci√≥n y guiado del hilo</div>
        </div>
      </div>
      <div class="legend-item" data-element="cooling">
        <div class="legend-color" style="background:#00aaff;"></div>
        <div class="legend-text">
          <div class="legend-name">Sistema Enfriamiento</div>
          <div class="legend-desc">Sprays de agua azul claro</div>
        </div>
      </div>
      <div class="legend-item" data-element="transformer">
        <div class="legend-color" style="background:#6688ff;"></div>
        <div class="legend-text">
          <div class="legend-name">Transformador El√©ctrico</div>
          <div class="legend-desc">Alimentaci√≥n 4000 kVA color azul-violeta</div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- MODAL: Informaci√≥n de Elemento (al hacer clic en 3D) -->
  <div id="infoModal" class="modal-overlay">
    <div class="modal-panel">
      <div class="modal-header">
        <h2 id="infoTitle">Elemento Seleccionado</h2>
        <div class="modal-close">√ó</div>
      </div>
      <div id="infoContent">
        <p><span class="info-label">Descripci√≥n:</span><span id="infoDesc">-</span></p>
        <p><span class="info-label">Funci√≥n:</span><span id="infoFunc">-</span></p>
        <p><span class="info-label">Especificaciones:</span><span id="infoSpecs">-</span></p>
      </div>
    </div>
  </div>
  
  <!-- MODAL: Todos los Equipos -->
  <div id="equipModal" class="modal-overlay">
    <div class="modal-panel">
      <div class="modal-header">
        <h2>‚öôÔ∏è Todos los Equipos</h2>
        <div class="modal-close">√ó</div>
      </div>
      
      <h3>üî• Equipos Principales</h3>
      <div class="equipment-section">
        <div class="equipment-name">Horno de Inducci√≥n</div>
        <div class="equipment-desc">Sistema de fusi√≥n por inducci√≥n electromagn√©tica de alta frecuencia. Ubicado cerca del transformador con conexi√≥n el√©ctrica trif√°sica visible (cables rojo-azul-amarillo). Cilindro refractario de color rojizo con 5 bobinas de inducci√≥n naranjas. Capacidad de 5 toneladas/hora con potencia de 3500 kW alimentada por el transformador. Panel de control con pantalla verde y botones iluminados. Alcanza temperaturas superiores a 1600¬∞C para fundir acero reciclado. El acero fundido se vierte en el ladle para su transporte.</div>
        <span class="equipment-tag">ON - OPERANDO</span>
      </div>
      
      <div class="equipment-section">
        <div class="equipment-name">Ladle (Cuchar√≥n)</div>
        <div class="equipment-desc">Recipiente refractario de acero con revestimiento cer√°mico interno. Transporta el acero fundido desde el horno hasta el tundish. Capacidad aproximada de 8 toneladas. Incluye sistema de vertido controlado.</div>
        <span class="equipment-tag">EN USO</span>
      </div>
      
      <div class="equipment-section">
        <div class="equipment-name">Tundish (Distribuidor)</div>
        <div class="equipment-desc">Recipiente intermedio que regula el flujo de acero l√≠quido hacia el molde. Funci√≥n de filtrado de impurezas y control de temperatura. Dise√±o en acero con revestimiento refractario azul distintivo.</div>
        <span class="equipment-tag">ACTIVO</span>
      </div>
      
      <div class="equipment-section">
        <div class="equipment-name">Molde de Cobre (Mold)</div>
        <div class="equipment-desc">Molde oscilante de cobre refrigerado por agua. Dimensiones para palanquillas de 150√ó150 mm. Sistema de enfriamiento interno con circuitos de agua a alta presi√≥n. Primera etapa de solidificaci√≥n.</div>
        <span class="equipment-tag">RUN - COLANDO</span>
      </div>
      
      <div class="equipment-section">
        <div class="equipment-name">Sistema de Rodillos</div>
        <div class="equipment-desc">Conjunto de rodillos gu√≠a distribuidos en zona vertical y curva. Funci√≥n de soporte y tracci√≥n del hilo continuo. Incluye rodillos verticales (zona de enfriamiento) y horizontales (zona de salida).</div>
        <span class="equipment-tag">OPERANDO</span>
      </div>
      
      <h3>‚ö° Equipos Auxiliares</h3>
      <div class="equipment-section">
        <div class="equipment-name">Transformador El√©ctrico</div>
        <div class="equipment-desc">Transformador de potencia 4000 kVA para alimentaci√≥n del horno de inducci√≥n. Incluye sistema de protecci√≥n y refrigeraci√≥n por aceite. Voltaje de entrada: 13.8 kV, salida regulable.</div>
        <span class="equipment-tag">OK - NORMAL</span>
      </div>
      
      <div class="equipment-section">
        <div class="equipment-name">Gr√∫a Puente (Overhead Crane)</div>
        <div class="equipment-desc">Gr√∫a puente de 15 toneladas de capacidad. Sistema de trolley m√≥vil con poleas dobles. Utilizada para transporte del ladle entre horno y tundish. Velocidad variable y control de precisi√≥n.</div>
        <span class="equipment-tag">AUTO - CICLO</span>
      </div>
      
      <div class="equipment-section">
        <div class="equipment-name">Sistema de Enfriamiento</div>
        <div class="equipment-desc">Torre de enfriamiento de 500 m¬≥/h de capacidad. Circuito cerrado con bombas de recirculaci√≥n. Sprays de agua en anillos para enfriamiento secundario del hilo. Temperatura de entrada: 32¬∞C, salida: 28¬∞C.</div>
        <span class="equipment-tag">70% CARGA</span>
      </div>
      
      <div class="equipment-section">
        <div class="equipment-name">Sistema de Control PLC + SCADA</div>
        <div class="equipment-desc">Control automatizado mediante PLC industrial con interfaz SCADA. Monitoreo en tiempo real de temperatura, velocidad de colada, nivel de tundish y posici√≥n de gr√∫a. Registro hist√≥rico de producci√≥n.</div>
        <span class="equipment-tag">ONLINE</span>
      </div>
      
      <div class="equipment-section">
        <div class="equipment-name">Sensores y Medici√≥n</div>
        <div class="equipment-desc">Red de sensores industriales: termopares tipo K para temperatura (hasta 1700¬∞C), sensores de nivel por radar, caudal√≠metros electromagn√©ticos, encoders de posici√≥n. Comunicaci√≥n por protocolo Profibus.</div>
        <span class="equipment-tag">OK - CALIBRADO</span>
      </div>
      
      <h3>üîß Proceso de Colada Continua</h3>
      <div class="equipment-section">
        <div class="equipment-desc">
          <strong>1. Alimentaci√≥n El√©ctrica:</strong> El transformador de 4000 kVA alimenta al horno mediante cables trif√°sicos (rojo-azul-amarillo).<br><br>
          <strong>2. Fusi√≥n:</strong> El horno de inducci√≥n (color rojizo con bobinas naranjas) funde el acero mediante campos electromagn√©ticos, alcanzando 1550-1600¬∞C. La abertura superior brilla intensamente.<br><br>
          <strong>3. Llenado del Ladle:</strong> El acero fundido del horno se vierte en el ladle (cuchar√≥n gris) con sistema de vertido controlado.<br><br>
          <strong>4. Transporte:</strong> La gr√∫a puente amarilla transporta el ladle con acero fundido hacia el tundish.<br><br>
          <strong>5. Vertido:</strong> El acero l√≠quido rojo brillante se vierte del ladle al tundish azul de forma controlada.<br><br>
          <strong>6. Distribuci√≥n:</strong> El tundish regula el flujo hacia el molde de cobre naranja.<br><br>
          <strong>7. Solidificaci√≥n Primaria:</strong> El molde refrigerado por agua inicia la solidificaci√≥n.<br><br>
          <strong>8. Enfriamiento Secundario:</strong> Sprays de agua azul claro enfr√≠an progresivamente el hilo.<br><br>
          <strong>9. Enderezado:</strong> Los rodillos grises gu√≠an y enderezan el hilo en curva vertical-horizontal.<br><br>
          <strong>10. Corte:</strong> El hilo solidificado se corta en palanquillas de longitud deseada.
        </div>
      </div>
    </div>
  </div>
  
  <!-- Controles de Simulaci√≥n -->
  <div id="controls">
    <button id="btnPlay">‚ñ∂ Iniciar</button>
    <button id="btnPause">‚è∏ Pausa</button>
    <button id="btnReset">‚Ü∫ Reiniciar</button>
    <button id="btnIso">‚åó Isom√©trica</button>
    <button id="btnTop">‚¨á Superior</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer; let isRunning=true; let t=0;
    let rollersV=[], rollersH=[], sprays=[], molten, ladle, strand, particles=[], tundishPool;
    let path, pathLen=1, u=0;
    let craneTrolley, craneHook, cranePulley1, cranePulley2, craneHookCable; // Elementos de la gr√∫a
    let furnaceBody, furnaceGroup; // Horno de inducci√≥n para animaci√≥n
    let furnaceMolten; // Chorro del horno al ladle
    let furnaceParticles = []; // Gotas del horno al ladle
    const params={ speed:0.005 }; // M√°s lento para ver el proceso

    init(); animate();

    function init(){
      try {
        console.log('Iniciando simulaci√≥n...');
      const canvas=document.getElementById('scene');
      renderer=new THREE.WebGLRenderer({canvas, antialias:true});
      renderer.setSize(innerWidth, innerHeight); renderer.setPixelRatio(devicePixelRatio);
      renderer.setClearColor(0x0b0f1a, 1);
        if(!renderer.getContext){ alert('WebGL no soportado en este navegador. Prueba Chrome/Edge/Opera con aceleraci√≥n de hardware.'); return; }
      scene=new THREE.Scene(); scene.background=new THREE.Color(0x0b0f1a);
        console.log('Escena creada correctamente');

      camera=new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 2000);
      camera.position.set(80,45,110); camera.lookAt(0,10,0);

      // Controles de mouse para rotar
      let isDragging=false, prevMouse={x:0,y:0};
      canvas.addEventListener('mousedown',e=>{isDragging=true; prevMouse={x:e.clientX,y:e.clientY};});
      canvas.addEventListener('mousemove',e=>{
        if(!isDragging)return;
        const dx=e.clientX-prevMouse.x, dy=e.clientY-prevMouse.y;
        const radius=Math.sqrt(camera.position.x**2+camera.position.y**2+camera.position.z**2);
        const theta=Math.atan2(camera.position.z,camera.position.x);
        const phi=Math.acos(camera.position.y/radius);
        const newTheta=theta-dx*0.005, newPhi=Math.max(0.1,Math.min(Math.PI-0.1,phi+dy*0.005));
        camera.position.x=radius*Math.sin(newPhi)*Math.cos(newTheta);
        camera.position.y=radius*Math.cos(newPhi);
        camera.position.z=radius*Math.sin(newPhi)*Math.sin(newTheta);
        camera.lookAt(0,10,0);
        prevMouse={x:e.clientX,y:e.clientY};
      });
      canvas.addEventListener('mouseup',()=>isDragging=false);
      canvas.addEventListener('wheel',e=>{
        e.preventDefault();
        const factor=1+e.deltaY*0.001;
        camera.position.multiplyScalar(factor);
      });

      const amb=new THREE.AmbientLight(0x445566,0.4); scene.add(amb);
      const dir=new THREE.DirectionalLight(0xffffff,1.8); dir.position.set(80,120,90); 
      dir.castShadow=true; dir.shadow.mapSize.width=2048; dir.shadow.mapSize.height=2048;
      dir.shadow.camera.left=-100; dir.shadow.camera.right=100; dir.shadow.camera.top=100; dir.shadow.camera.bottom=-100;
      scene.add(dir);
      const hot=new THREE.PointLight(0xff6600,4,120); hot.position.set(-40,48,0); hot.castShadow=true; scene.add(hot);
      renderer.shadowMap.enabled=true; renderer.shadowMap.type=THREE.PCFSoftShadowMap;

      const grid=new THREE.GridHelper(400, 40, 0x1f3349, 0x0d2033); 
      grid.position.y=-40; 
      scene.add(grid);
      console.log('Grid agregado');
      
      const axes=new THREE.AxesHelper(15); 
      axes.position.set(0,0,0); 
      scene.add(axes);
      console.log('Ejes agregados');

      console.log('Construyendo horno...');
      buildInductionFurnace();
      console.log('Construyendo ladle y tundish...');
      buildLadleTundishMold();
      console.log('Construyendo path...');
      buildCasterPath();
      console.log('Construyendo rodillos...');
      buildRollersAndSprays();
      console.log('Construyendo strand...');
      buildStrand();
      console.log('Configurando interacci√≥n...');
      setupClickInteraction();
      
      // Inicializar modales
      setTimeout(() => {
        initModals();
      }, 100);

      window.addEventListener('resize', onResize);
      bindUI();
      
      console.log('Simulaci√≥n iniciada correctamente');
      } catch(error) {
        console.error('Error al inicializar:', error);
        alert('Error al cargar la simulaci√≥n: ' + error.message);
      }
    }

    // Sistema de interacci√≥n con elementos 3D
    function setupClickInteraction(){
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      
      // Datos de informaci√≥n de cada elemento
      const elementInfo = {
        furnace: {
          title: 'Horno de Inducci√≥n',
          desc: 'Sistema de fusi√≥n electromagn√©tica de alta frecuencia',
          func: 'Funde el acero mediante inducci√≥n electromagn√©tica, alcanzando 1600¬∞C',
          specs: 'Capacidad: 5 t/h | Potencia: 3500 kW | Bobinas de inducci√≥n | Alimentado por transformador'
        },
        ladle: {
          title: 'Ladle (Cuchar√≥n)',
          desc: 'Recipiente refractario de acero con revestimiento cer√°mico interno',
          func: 'Transporta el acero fundido desde el horno hasta el tundish',
          specs: 'Capacidad: 8 toneladas | Material: Acero + refractario | Temp. m√°x: 1700¬∞C'
        },
        tundish: {
          title: 'Tundish (Distribuidor)',
          desc: 'Recipiente intermedio de control de flujo',
          func: 'Regula el flujo de acero l√≠quido hacia el molde y filtra impurezas',
          specs: 'Material: Acero + refractario azul | Control de temperatura | Capacidad: 4 toneladas'
        },
        mold: {
          title: 'Molde de Cobre',
          desc: 'Molde oscilante refrigerado por agua',
          func: 'Primera etapa de solidificaci√≥n del acero fundido',
          specs: 'Dimensiones: 150√ó150 mm | Oscilaci√≥n: 60-200 ciclos/min | Enfriamiento: agua a 300 L/min'
        },
        crane: {
          title: 'Gr√∫a Puente (Overhead Crane)',
          desc: 'Sistema de transporte a√©reo con trolley m√≥vil',
          func: 'Transporte del ladle entre horno y posici√≥n de vertido',
          specs: 'Capacidad: 15 toneladas | Velocidad: variable 0.5-2 m/s | Control autom√°tico'
        },
        rollers: {
          title: 'Sistema de Rodillos',
          desc: 'Conjunto de rodillos gu√≠a en zonas vertical, curva y horizontal',
          func: 'Soporte, tracci√≥n y enderezamiento del hilo continuo',
          specs: 'Cantidad: ~30 rodillos | Material: acero | Di√°metro: 150-300 mm | Refrigerados'
        },
        cooling: {
          title: 'Sistema de Enfriamiento',
          desc: 'Sprays de agua en anillos para enfriamiento secundario',
          func: 'Reducir temperatura del hilo de 1000¬∞C a 200¬∞C progresivamente',
          specs: 'Torre: 500 m¬≥/h | Presi√≥n: 4-6 bar | Zona de sprays: 8-12 metros'
        },
        molten: {
          title: 'Acero Fundido',
          desc: 'Acero en estado l√≠quido fluyendo del ladle al tundish',
          func: 'Material base para la colada continua',
          specs: 'Temperatura: 1540-1580¬∞C | Composici√≥n: Fe + C (0.1-0.4%) + aleantes | Fluidez: alta'
        },
        transformer: {
          title: 'Transformador El√©ctrico',
          desc: 'Transformador de potencia para alimentaci√≥n del horno',
          func: 'Suministra energ√≠a el√©ctrica al sistema de inducci√≥n',
          specs: 'Potencia: 4000 kVA | Entrada: 13.8 kV | Salida: regulable | Refrigeraci√≥n: aceite'
        }
      };
      
      // Event listener para clics en el canvas
      const canvas = document.getElementById('scene');
      canvas.addEventListener('click', (event) => {
        // Calcular posici√≥n del mouse normalizada
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        // Actualizar raycaster
        raycaster.setFromCamera(mouse, camera);
        
        // Buscar intersecciones con todos los objetos de la escena
        const intersects = raycaster.intersectObjects(scene.children, true);
        
        if(intersects.length > 0){
          // Buscar el primer objeto con userData.elementType
          for(let i = 0; i < intersects.length; i++){
            const obj = intersects[i].object;
            let checkObj = obj;
            
            // Revisar el objeto y sus padres
            while(checkObj){
              if(checkObj.userData && checkObj.userData.elementType){
                const type = checkObj.userData.elementType;
                const info = elementInfo[type];
                if(info){
                  showInfoPanel(info);
                  return;
                }
              }
              checkObj = checkObj.parent;
            }
          }
        }
      });
      
      // Click en items de la leyenda
      document.querySelectorAll('.legend-item').forEach(item => {
        item.addEventListener('click', () => {
          const elementType = item.getAttribute('data-element');
          const info = elementInfo[elementType];
          if(info){
            showInfoPanel(info);
          }
        });
      });
    }
    
    // Sistema de modales
    function openModal(modalId){
      document.getElementById(modalId).classList.add('show');
    }
    
    function closeModal(modalId){
      document.getElementById(modalId).classList.remove('show');
    }
    
    // Mostrar informaci√≥n de elemento en modal
    function showInfoPanel(info){
      document.getElementById('infoTitle').textContent = info.title;
      document.getElementById('infoDesc').textContent = info.desc;
      document.getElementById('infoFunc').textContent = info.func;
      document.getElementById('infoSpecs').textContent = info.specs;
      openModal('infoModal');
    }
    
    // Inicializar botones y modales
    function initModals(){
      // Bot√≥n de informaci√≥n
      document.getElementById('hudBtn').onclick = () => openModal('hudModal');
      
      // Bot√≥n de convenciones
      document.getElementById('legendBtn').onclick = () => openModal('legendModal');
      
      // Bot√≥n de equipos
      document.getElementById('equipBtn').onclick = () => openModal('equipModal');
      
      // Cerrar modales con bot√≥n X
      document.querySelectorAll('.modal-close').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const modal = e.target.closest('.modal-overlay');
          if(modal) modal.classList.remove('show');
        });
      });
      
      // Cerrar modales al hacer clic fuera
      document.querySelectorAll('.modal-overlay').forEach(overlay => {
        overlay.addEventListener('click', (e) => {
          if(e.target === overlay){
            overlay.classList.remove('show');
          }
        });
      });
    }

    // HORNO DE INDUCCI√ìN con conexi√≥n al transformador
    function buildInductionFurnace(){
      const FURNACE_POS = {x: -60, y: 0, z: 0}; // Alineado con todos los elementos en Z=0
      
      // PLATAFORMA EXTENDIDA para el horno Y el cuchar√≥n (desde el horno hasta donde est√° el cuchar√≥n)
      const extendedPlatform = new THREE.Mesh(
        new THREE.BoxGeometry(25, 3, 15), // Plataforma larga que se extiende hacia la derecha
        new THREE.MeshStandardMaterial({color: 0x3a3a3a, metalness:0.7, roughness:0.5})
      );
      extendedPlatform.position.set(-58, 8, 0); // Centrada entre el horno (-60) y el cuchar√≥n (-58)
      extendedPlatform.castShadow = true;
      extendedPlatform.receiveShadow = true;
      scene.add(extendedPlatform);
      
      // Vigas de soporte bajo la plataforma
      for(let x of [-68, -55, -48]){
        const beam = new THREE.Mesh(
          new THREE.BoxGeometry(2, 8, 2),
          new THREE.MeshStandardMaterial({color: 0x444444, metalness:0.8})
        );
        beam.position.set(x, 4, -5);
        beam.castShadow = true;
        scene.add(beam);
        
        const beam2 = new THREE.Mesh(
          new THREE.BoxGeometry(2, 8, 2),
          new THREE.MeshStandardMaterial({color: 0x444444, metalness:0.8})
        );
        beam2.position.set(x, 4, 5);
        beam2.castShadow = true;
        scene.add(beam2);
      }
      
      // Base del horno (plataforma circular sobre la plataforma extendida)
      const furnaceBase = new THREE.Mesh(
        new THREE.CylinderGeometry(12, 13, 2, 32),
        new THREE.MeshStandardMaterial({color: 0x2a2a2a, metalness:0.8, roughness:0.4})
      );
      furnaceBase.position.set(FURNACE_POS.x, 10, FURNACE_POS.z);
      furnaceBase.castShadow = true;
      furnaceBase.receiveShadow = true;
      scene.add(furnaceBase);
      
      // GRUPO del horno que puede rotar (bascularse)
      furnaceGroup = new THREE.Group();
      furnaceGroup.position.set(FURNACE_POS.x, 19.5, FURNACE_POS.z);
      
      // Cuerpo principal del horno (cilindro refractario)
      furnaceBody = new THREE.Mesh(
        new THREE.CylinderGeometry(10, 10, 20, 32),
        new THREE.MeshStandardMaterial({
          color: 0xaa4444, 
          metalness:0.3, 
          roughness:0.6,
          emissive: 0xff3300,
          emissiveIntensity: 0.5
        })
      );
      furnaceBody.castShadow = true;
      furnaceBody.receiveShadow = true;
      furnaceBody.userData.elementType = 'furnace';
      furnaceGroup.add(furnaceBody);
      
      // Bobinas de inducci√≥n (parte del grupo rotatorio)
      for(let i = 0; i < 5; i++){
        const coil = new THREE.Mesh(
          new THREE.TorusGeometry(10.5, 0.8, 16, 32),
          new THREE.MeshStandardMaterial({
            color: 0xcc7700,
            metalness: 0.9,
            roughness: 0.2,
            emissive: 0xff6600,
            emissiveIntensity: 0.8
          })
        );
        coil.position.set(0, -7.5 + i*3.5, 0); // Posici√≥n relativa al grupo
        coil.rotation.x = Math.PI/2;
        coil.castShadow = true;
        furnaceGroup.add(coil);
      }
      
      // Tapa superior del horno (parte del grupo)
      const furnaceLid = new THREE.Mesh(
        new THREE.CylinderGeometry(11, 10, 2, 32),
        new THREE.MeshStandardMaterial({
          color: 0x333333,
          metalness: 0.9,
          roughness: 0.3
        })
      );
      furnaceLid.position.set(0, 10.5, 0); // Posici√≥n relativa
      furnaceLid.castShadow = true;
      furnaceGroup.add(furnaceLid);
      
      // Abertura superior (boca del horno) con brillo intenso
      const furnaceOpening = new THREE.Mesh(
        new THREE.CylinderGeometry(4, 4, 1, 32),
        new THREE.MeshStandardMaterial({
          color: 0xffaa00,
          emissive: 0xff6600,
          emissiveIntensity: 5,
          transparent: true,
          opacity: 0.9
        })
      );
      furnaceOpening.position.set(0, 11.5, 0); // Posici√≥n relativa
      furnaceGroup.add(furnaceOpening);
      
      // PICO VERTEDOR LATERAL IZQUIERDO (canal por donde sale el l√≠quido al inclinarse)
      const spoutGroup = new THREE.Group();
      
      // Canal principal del pico (semicircular)
      const spoutChannel = new THREE.Mesh(
        new THREE.CylinderGeometry(1.5, 2, 8, 16, 1, false, 0, Math.PI), // Medio cilindro
        new THREE.MeshStandardMaterial({
          color: 0x666666,
          metalness: 0.9,
          roughness: 0.3
        })
      );
      spoutChannel.rotation.z = Math.PI/2; // Horizontal
      spoutChannel.rotation.y = Math.PI/2; // Orientado hacia la IZQUIERDA
      spoutChannel.position.set(-10, 8, 0); // Lado IZQUIERDO del horno
      spoutChannel.castShadow = true;
      spoutGroup.add(spoutChannel);
      
      // Borde del canal (refuerzo)
      const spoutEdge1 = new THREE.Mesh(
        new THREE.BoxGeometry(8, 0.3, 0.3),
        new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.9})
      );
      spoutEdge1.position.set(-10, 9.5, 0);
      spoutEdge1.rotation.z = Math.PI/2;
      spoutGroup.add(spoutEdge1);
      
      const spoutEdge2 = new THREE.Mesh(
        new THREE.BoxGeometry(8, 0.3, 0.3),
        new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.9})
      );
      spoutEdge2.position.set(-10, 6.5, 0);
      spoutEdge2.rotation.z = Math.PI/2;
      spoutGroup.add(spoutEdge2);
      
      // Punta del pico (parte que vierte)
      const spoutTip = new THREE.Mesh(
        new THREE.CylinderGeometry(1.2, 1.5, 2, 12),
        new THREE.MeshStandardMaterial({
          color: 0x555555,
          metalness: 0.9,
          roughness: 0.2
        })
      );
      spoutTip.rotation.z = Math.PI/2;
      spoutTip.position.set(-15, 8, 0); // Punta a la izquierda
      spoutTip.castShadow = true;
      spoutGroup.add(spoutTip);
      
      // Brillo del metal fundido dentro del pico
      const spoutGlow = new THREE.Mesh(
        new THREE.CylinderGeometry(1, 1.2, 6, 12),
        new THREE.MeshStandardMaterial({
          color: 0xff6600,
          emissive: 0xff3300,
          emissiveIntensity: 3,
          transparent: true,
          opacity: 0.7
        })
      );
      spoutGlow.rotation.z = Math.PI/2;
      spoutGlow.position.set(-11, 8, 0);
      spoutGroup.add(spoutGlow);
      
      // Soporte estructural del pico
      const spoutSupport = new THREE.Mesh(
        new THREE.BoxGeometry(4, 0.8, 3),
        new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.8})
      );
      spoutSupport.position.set(-9, 6, 0);
      spoutSupport.castShadow = true;
      spoutGroup.add(spoutSupport);
      
      furnaceGroup.add(spoutGroup);
      
      // Agregar el grupo del horno a la escena
      scene.add(furnaceGroup);
      
      // Luz intensa del horno (simula el calor)
      const furnaceLight = new THREE.PointLight(0xff4400, 8, 60);
      furnaceLight.position.set(FURNACE_POS.x, 25, FURNACE_POS.z);
      furnaceLight.castShadow = true;
      scene.add(furnaceLight);
      
      // Panel de control del horno (LADO DERECHO)
      const controlPanel = new THREE.Mesh(
        new THREE.BoxGeometry(3, 4, 1),
        new THREE.MeshStandardMaterial({
          color: 0x1a1a1a,
          metalness: 0.7,
          roughness: 0.3
        })
      );
      controlPanel.position.set(FURNACE_POS.x + 8, 15, FURNACE_POS.z + 8);
      controlPanel.rotation.y = Math.PI/4; // Rotado hacia el lado derecho
      controlPanel.castShadow = true;
      scene.add(controlPanel);
      
      // Pantalla del panel (verde)
      const screen = new THREE.Mesh(
        new THREE.BoxGeometry(2, 1.5, 0.2),
        new THREE.MeshStandardMaterial({
          color: 0x00ff00,
          emissive: 0x00ff00,
          emissiveIntensity: 2
        })
      );
      screen.position.set(FURNACE_POS.x + 8.3, 16, FURNACE_POS.z + 8.3);
      screen.rotation.y = Math.PI/4;
      scene.add(screen);
      
      // Botones del panel
      for(let i = 0; i < 4; i++){
        const button = new THREE.Mesh(
          new THREE.CylinderGeometry(0.2, 0.2, 0.3, 16),
          new THREE.MeshStandardMaterial({
            color: i === 0 ? 0xff0000 : 0x00ff00,
            emissive: i === 0 ? 0xff0000 : 0x00ff00,
            emissiveIntensity: 1.5
          })
        );
        button.position.set(FURNACE_POS.x + 8.4 - (i%2)*0.6, 14.2 + Math.floor(i/2)*0.5, FURNACE_POS.z + 8.4);
        button.rotation.x = Math.PI/2;
        button.rotation.z = Math.PI/4;
        scene.add(button);
      }
      
      // CONEXI√ìN EL√âCTRICA VISIBLE: Transformador ‚Üí Horno (actualizado a nuevas posiciones)
      // Cables gruesos (3 cables de potencia)
      const cableColors = [0xff0000, 0x0000ff, 0xffff00]; // Rojo, azul, amarillo (trif√°sico)
      for(let i = 0; i < 3; i++){
        // Cable principal desde transformador (ahora a un lado) hasta el horno
        const cablePath = new THREE.CatmullRomCurve3([
          new THREE.Vector3(-78, 28, -15),  // Desde transformador (nueva posici√≥n)
          new THREE.Vector3(-75, 28, -10),
          new THREE.Vector3(-70, 26, -5),
          new THREE.Vector3(-65, 24, 0),
          new THREE.Vector3(-60, 22, 0) // Hasta horno
        ]);
        
        const cableGeometry = new THREE.TubeGeometry(cablePath, 30, 0.4, 8, false);
        const cable = new THREE.Mesh(
          cableGeometry,
          new THREE.MeshStandardMaterial({
            color: cableColors[i],
            metalness: 0.6,
            roughness: 0.4
          })
        );
        cable.position.z = i * 0.6 - 0.6; // Separar los cables
        cable.castShadow = true;
        scene.add(cable);
      }
      
      // Conducto protector de cables (bandeja) - actualizado
      const cableTray = new THREE.Mesh(
        new THREE.BoxGeometry(20, 1, 4),
        new THREE.MeshStandardMaterial({
          color: 0x555555,
          metalness: 0.8,
          roughness: 0.4
        })
      );
      cableTray.position.set(-69, 27, -7);
      cableTray.rotation.y = -Math.PI/6;
      cableTray.castShadow = true;
      scene.add(cableTray);
      
      // Caja de conexi√≥n en el horno
      const connectionBox = new THREE.Mesh(
        new THREE.BoxGeometry(3, 4, 2),
        new THREE.MeshStandardMaterial({
          color: 0x333333,
          metalness: 0.9,
          roughness: 0.2
        })
      );
      connectionBox.position.set(FURNACE_POS.x, 28, FURNACE_POS.z + 8);
      connectionBox.castShadow = true;
      scene.add(connectionBox);
      
      // Se√±al de alto voltaje
      const warningSign = new THREE.Mesh(
        new THREE.BoxGeometry(2, 2, 0.2),
        new THREE.MeshStandardMaterial({
          color: 0xffff00,
          emissive: 0xffaa00,
          emissiveIntensity: 0.5
        })
      );
      warningSign.position.set(FURNACE_POS.x + 10, 20, FURNACE_POS.z);
      warningSign.castShadow = true;
      scene.add(warningSign);
      
      // S√≠mbolo de rayo (peligro el√©ctrico)
      const lightningGeometry = new THREE.BufferGeometry();
      const vertices = new Float32Array([
        0, 0.8, 0,
        -0.3, 0, 0,
        0.1, 0, 0,
        -0.2, -0.8, 0,
        0.3, 0.1, 0,
        -0.1, 0.1, 0
      ]);
      lightningGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
      const lightning = new THREE.Mesh(
        lightningGeometry,
        new THREE.MeshBasicMaterial({color: 0x000000, side: THREE.DoubleSide})
      );
      lightning.position.set(FURNACE_POS.x + 10, 20, FURNACE_POS.z + 0.2);
      scene.add(lightning);
      
      // Estructura de soporte
      const support1 = new THREE.Mesh(
        new THREE.CylinderGeometry(1, 1.2, 10, 16),
        new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.8})
      );
      support1.position.set(FURNACE_POS.x - 10, 5, FURNACE_POS.z - 10);
      support1.castShadow = true;
      scene.add(support1);
      
      const support2 = new THREE.Mesh(
        new THREE.CylinderGeometry(1, 1.2, 10, 16),
        new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.8})
      );
      support2.position.set(FURNACE_POS.x + 10, 5, FURNACE_POS.z - 10);
      support2.castShadow = true;
      scene.add(support2);
      
      const support3 = new THREE.Mesh(
        new THREE.CylinderGeometry(1, 1.2, 10, 16),
        new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.8})
      );
      support3.position.set(FURNACE_POS.x - 10, 5, FURNACE_POS.z + 10);
      support3.castShadow = true;
      scene.add(support3);
      
      const support4 = new THREE.Mesh(
        new THREE.CylinderGeometry(1, 1.2, 10, 16),
        new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.8})
      );
      support4.position.set(FURNACE_POS.x + 10, 5, FURNACE_POS.z + 10);
      support4.castShadow = true;
      scene.add(support4);
      
      // CHORRO DE FUNDIDO del horno al ladle (inicialmente invisible)
      const furnacePourPath = new THREE.CatmullRomCurve3([
        new THREE.Vector3(-60, 30, -25),  // Desde boca del horno
        new THREE.Vector3(-50, 25, -15),
        new THREE.Vector3(-40, 20, -5),
        new THREE.Vector3(-30, 15, 0)     // Hacia ladle
      ]);
      const furnacePourGeometry = new THREE.TubeGeometry(furnacePourPath, 24, 1.5, 12, false);
      furnaceMolten = new THREE.Mesh(
        furnacePourGeometry,
        new THREE.MeshStandardMaterial({
          color: 0xff3300,
          emissive: 0xff5500,
          emissiveIntensity: 5,
          transparent: true,
          opacity: 0.95
        })
      );
      furnaceMolten.visible = false;
      scene.add(furnaceMolten);
    }

    function buildLadleTundishMold(){
      // Ladle GRIS - CON DETALLES seg√∫n imagen de referencia
      const LADLE_HEIGHT = 70; // MUY ALTO para estar por encima
      const ladleGroup = new THREE.Group();
      
      // Cuerpo principal del ladle
      const cupOuter=new THREE.Mesh(new THREE.CylinderGeometry(7,8,12,16), new THREE.MeshStandardMaterial({color:0x999999, metalness:.8, roughness:.3}));
      cupOuter.castShadow=true; ladleGroup.add(cupOuter);
      
      // Refuerzos horizontales (bandas met√°licas)
      for(let i=0; i<3; i++){
        const band=new THREE.Mesh(new THREE.TorusGeometry(7.3+i*0.3, 0.3, 8, 16), new THREE.MeshStandardMaterial({color:0x777777, metalness:0.9}));
        band.position.y = -4 + i*4;
        band.rotation.x = Math.PI/2;
        band.castShadow=true;
        ladleGroup.add(band);
      }
      
      // Tornillos/remaches alrededor del ladle
      for(let ring=0; ring<2; ring++){
        for(let a=0; a<8; a++){
          const angle = a/8 * Math.PI * 2;
          const bolt=new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.4, 6), new THREE.MeshStandardMaterial({color:0x333333, metalness:0.95}));
          bolt.position.set(Math.cos(angle)*7.5, -3+ring*6, Math.sin(angle)*7.5);
          bolt.rotation.z = Math.PI/2;
          bolt.castShadow=true;
          ladleGroup.add(bolt);
        }
      }
      
      // Borde superior reforzado
      const rim=new THREE.Mesh(new THREE.TorusGeometry(7, 0.5, 8, 16), new THREE.MeshStandardMaterial({color:0x888888, metalness:0.9}));
      rim.position.y = 6;
      rim.rotation.x = Math.PI/2;
      rim.castShadow=true;
      ladleGroup.add(rim);
      
      // Pico de vertido FRONTAL (hacia donde vierte)
      const spout=new THREE.Mesh(new THREE.ConeGeometry(1.5, 3, 8), new THREE.MeshStandardMaterial({color:0xaaaaaa, metalness:0.8}));
      spout.position.set(6, 3, 0); // Posici√≥n frontal superior
      spout.rotation.z = -Math.PI/3; // Inclinado hacia adelante
      spout.castShadow=true;
      ladleGroup.add(spout);
      
      // Barandales de seguridad alrededor de la PLATAFORMA EXTENDIDA
      const railMaterial = new THREE.MeshStandardMaterial({color: 0xffff00, metalness: 0.7});
      
      // Postes de las barandas a lo largo de la plataforma
      for(let x of [-70, -65, -60, -55, -48]){
        for(let z of [-6.5, 6.5]){
          const post = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.2, 4, 8),
            railMaterial
          );
          post.position.set(x, 11.5, z);
          post.castShadow = true;
          scene.add(post);
        }
      }
      
      // Barandas horizontales largas
      const railH1 = new THREE.Mesh(
        new THREE.BoxGeometry(25, 0.15, 0.15),
        railMaterial
      );
      railH1.position.set(-58, 13.5, -6.5);
      scene.add(railH1);
      
      const railH2 = new THREE.Mesh(
        new THREE.BoxGeometry(25, 0.15, 0.15),
        railMaterial
      );
      railH2.position.set(-58, 13.5, 6.5);
      scene.add(railH2);
      
      // PLATAFORMA PARA EL CUCHAR√ìN (al lado del transformador, nivel m√°s bajo)
      const ladlePlatform = new THREE.Mesh(
        new THREE.BoxGeometry(15, 3, 15),
        new THREE.MeshStandardMaterial({color: 0x3a3a3a, metalness:0.7, roughness:0.5})
      );
      ladlePlatform.position.set(-78, 1.5, 5); // A la IZQUIERDA del horno, no encima
      ladlePlatform.castShadow = true;
      ladlePlatform.receiveShadow = true;
      scene.add(ladlePlatform);
      
      // Vigas de soporte para la plataforma del cuchar√≥n
      for(let x of [-85, -78, -71]){
        const beam = new THREE.Mesh(
          new THREE.BoxGeometry(2, 3, 2),
          new THREE.MeshStandardMaterial({color: 0x444444, metalness:0.8})
        );
        beam.position.set(x, 0, 0);
        beam.castShadow = true;
        scene.add(beam);
        
        const beam2 = new THREE.Mesh(
          new THREE.BoxGeometry(2, 3, 2),
          new THREE.MeshStandardMaterial({color: 0x444444, metalness:0.8})
        );
        beam2.position.set(x, 0, 10);
        beam2.castShadow = true;
        scene.add(beam2);
      }
      
      // Barandales de seguridad en la plataforma del cuchar√≥n
      const ladleRailMat = new THREE.MeshStandardMaterial({color: 0xffff00, metalness: 0.7});
      
      for(let x of [-85, -78, -71]){
        for(let z of [-2, 12]){
          const post = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.2, 3, 8),
            ladleRailMat
          );
          post.position.set(x, 4.5, z);
          post.castShadow = true;
          scene.add(post);
        }
      }
      
      // Barandas horizontales
      const ladleRailH1 = new THREE.Mesh(
        new THREE.BoxGeometry(15, 0.15, 0.15),
        ladleRailMat
      );
      ladleRailH1.position.set(-78, 6, -2);
      scene.add(ladleRailH1);
      
      const ladleRailH2 = new THREE.Mesh(
        new THREE.BoxGeometry(15, 0.15, 0.15),
        ladleRailMat
      );
      ladleRailH2.position.set(-78, 6, 12);
      scene.add(ladleRailH2);
      
      // POSICI√ìN INICIAL: Ladle A LA IZQUIERDA del horno, no encima
      ladleGroup.position.set(-78, 4, 5); // A la izquierda del horno
      ladleGroup.rotation.z = 0; // Vertical
      ladleGroup.userData.elementType = 'ladle'; // Marcar para interacci√≥n
      scene.add(ladleGroup);
      ladle = ladleGroup;
      
      // Asa/gancho ladle MEJORADO (doble barra)
      const hookGroup = new THREE.Group();
      const hookBar1=new THREE.Mesh(new THREE.BoxGeometry(0.5, 6, 0.5), new THREE.MeshStandardMaterial({color:0x666666, metalness:0.9}));
      hookBar1.position.x = -1;
      hookBar1.castShadow=true;
      hookGroup.add(hookBar1);
      
      const hookBar2=new THREE.Mesh(new THREE.BoxGeometry(0.5, 6, 0.5), new THREE.MeshStandardMaterial({color:0x666666, metalness:0.9}));
      hookBar2.position.x = 1;
      hookBar2.castShadow=true;
      hookGroup.add(hookBar2);
      
      const hookTop=new THREE.Mesh(new THREE.BoxGeometry(3, 0.8, 0.8), new THREE.MeshStandardMaterial({color:0x666666, metalness:0.9}));
      hookTop.position.y = 3;
      hookTop.castShadow=true;
      hookGroup.add(hookTop);
      
      hookGroup.position.set(-3, LADLE_HEIGHT+6, 0);
      scene.add(hookGroup);
      
      // Polea superior para ladle CON M√ÅS DETALLE
      const pulleyGroup = new THREE.Group();
      const pulleyWheel=new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 1.2, 16), new THREE.MeshStandardMaterial({color:0x444444, metalness:0.9}));
      pulleyWheel.rotation.z=Math.PI/2;
      pulleyWheel.castShadow=true;
      pulleyGroup.add(pulleyWheel);
      
      // Ranuras de la polea
      for(let i=0; i<3; i++){
        const groove=new THREE.Mesh(new THREE.TorusGeometry(2.1, 0.1, 6, 16), new THREE.MeshStandardMaterial({color:0x222222}));
        groove.position.x = -0.5 + i*0.5;
        groove.rotation.y = Math.PI/2;
        pulleyGroup.add(groove);
      }
      
      pulleyGroup.position.set(-3, LADLE_HEIGHT+12, 0);
      scene.add(pulleyGroup);
      
      // Cables de la polea (dobles)
      for(let i=-0.3; i<=0.3; i+=0.6){
        const cable=new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 5, 6), new THREE.MeshStandardMaterial({color:0x333333, metalness:0.8}));
        cable.position.set(-3+i, LADLE_HEIGHT+9.5, 0);
        scene.add(cable);
      }
      
      // Chorro l√≠quido desde el ladle al tundish - CA√çDA LARGA Y VISIBLE
      // Posici√≥n inicial ajustada para que salga del pico frontal
      const pts=[new THREE.Vector3(2,70,0), new THREE.Vector3(1,60,0), new THREE.Vector3(0,50,0)];
      const curve=new THREE.CatmullRomCurve3(pts);
      const tubeGeo=new THREE.TubeGeometry(curve,24,1.8,12,false);
      molten=new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({color:0xff3300, emissive:0xff5500, emissiveIntensity:5}));
      molten.userData.elementType = 'molten'; // Marcar para interacci√≥n
      scene.add(molten);

      // TUNDISH AZUL CYAN - ELEVADO - OPTIMIZADO para mejor rendimiento
      const tundishGroup=new THREE.Group();
      const TUNDISH_HEIGHT = 48; // M√ÅS ELEVADO (antes 38)
      
      // Pared exterior cil√≠ndrica (hueca) - AZUL CYAN - OPTIMIZADA
      const outerWall=new THREE.Mesh(
        new THREE.CylinderGeometry(10,10,10,20,1,true), 
        new THREE.MeshStandardMaterial({color:0x0099cc, metalness:0.7, roughness:0.4, emissive:0x006699, emissiveIntensity:0.4, side:THREE.DoubleSide})
      );
      outerWall.position.y=TUNDISH_HEIGHT; outerWall.castShadow=true; outerWall.receiveShadow=true; tundishGroup.add(outerWall);
      
      // Pared interior (para dar grosor) - AZUL - OPTIMIZADA
      const innerWall=new THREE.Mesh(
        new THREE.CylinderGeometry(9,9,10,20,1,true), 
        new THREE.MeshStandardMaterial({color:0x0088bb, metalness:0.7, roughness:0.5, side:THREE.DoubleSide})
      );
      innerWall.position.y=TUNDISH_HEIGHT; tundishGroup.add(innerWall);
      
      // Base s√≥lida del tundish - AZUL - OPTIMIZADA
      const tundishBase=new THREE.Mesh(
        new THREE.CylinderGeometry(9,10,1,20), 
        new THREE.MeshStandardMaterial({color:0x0099cc, metalness:0.8, roughness:0.5})
      );
      tundishBase.position.y=TUNDISH_HEIGHT-5; tundishBase.receiveShadow=true; tundishGroup.add(tundishBase);
      
      scene.add(tundishGroup);
      
      // Anillos reforzadores externos - AZUL OSCURO - OPTIMIZADOS
      for(let i=0;i<2;i++){
        const ring=new THREE.Mesh(new THREE.TorusGeometry(10.5,0.4,8,20), new THREE.MeshStandardMaterial({color:0x005588, metalness:0.9}));
        ring.position.set(0,TUNDISH_HEIGHT-3+i*5,0); ring.rotation.x=Math.PI/2; ring.castShadow=false; scene.add(ring);
      }
      
      // SISTEMA DE POLEA PARA INCLINAR EL LADLE (control manual)
      // Estructura de soporte para la polea de control
      const pulleySupport = new THREE.Mesh(
        new THREE.BoxGeometry(1, 15, 1),
        new THREE.MeshStandardMaterial({color: 0x666666, metalness: 0.8})
      );
      pulleySupport.position.set(8, TUNDISH_HEIGHT + 2, -8);
      pulleySupport.castShadow = true;
      scene.add(pulleySupport);
      
      // Brazo horizontal de la polea
      const pulleyArm = new THREE.Mesh(
        new THREE.BoxGeometry(8, 0.8, 0.8),
        new THREE.MeshStandardMaterial({color: 0x666666, metalness: 0.8})
      );
      pulleyArm.position.set(4, TUNDISH_HEIGHT + 10, -8);
      pulleyArm.castShadow = true;
      scene.add(pulleyArm);
      
      // Polea de control (rueda)
      const controlPulley = new THREE.Mesh(
        new THREE.CylinderGeometry(1.5, 1.5, 0.8, 20),
        new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.9})
      );
      controlPulley.rotation.z = Math.PI/2;
      controlPulley.position.set(0, TUNDISH_HEIGHT + 10, -8);
      controlPulley.castShadow = true;
      scene.add(controlPulley);
      
      // Cable de la polea (desde el ladle hasta la polea de control) - M√ÅS GRUESO Y VISIBLE
      const controlCablePath = new THREE.CatmullRomCurve3([
        new THREE.Vector3(-3, TUNDISH_HEIGHT + 9, 0), // Desde ladle
        new THREE.Vector3(-1, TUNDISH_HEIGHT + 9.5, -4),
        new THREE.Vector3(0, TUNDISH_HEIGHT + 10, -8) // Hasta polea
      ]);
      const controlCableGeo = new THREE.TubeGeometry(controlCablePath, 30, 0.3, 12, false);
      const controlCable = new THREE.Mesh(
        controlCableGeo,
        new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.9, emissive: 0x222222, emissiveIntensity: 0.2})
      );
      controlCable.castShadow = true;
      scene.add(controlCable);
      
      // Cable que baja desde la polea hasta el operador - MUY GRUESO Y VISIBLE
      const pullCablePath = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, TUNDISH_HEIGHT + 10, -8), // Desde la polea
        new THREE.Vector3(2, TUNDISH_HEIGHT + 5, -8.5),
        new THREE.Vector3(5, TUNDISH_HEIGHT + 2, -9),
        new THREE.Vector3(7, TUNDISH_HEIGHT + 1, -9.5) // Hasta cerca del operador
      ]);
      const pullCableGeo = new THREE.TubeGeometry(pullCablePath, 30, 0.35, 12, false);
      const pullCable = new THREE.Mesh(
        pullCableGeo,
        new THREE.MeshStandardMaterial({color: 0xffaa00, metalness: 0.9, emissive: 0xaa6600, emissiveIntensity: 0.3})
      );
      pullCable.castShadow = true;
      scene.add(pullCable);
      
      // Manija del cable (que el operador agarra) - ROJA BRILLANTE
      const cableHandle = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5, 2.5, 16),
        new THREE.MeshStandardMaterial({color: 0xff0000, metalness: 0.7, emissive: 0xaa0000, emissiveIntensity: 0.7})
      );
      cableHandle.rotation.z = Math.PI/2;
      cableHandle.position.set(7.5, TUNDISH_HEIGHT + 0.5, -9.5);
      cableHandle.castShadow = true;
      scene.add(cableHandle);
      
      // Cable del operador a la manija (conexi√≥n visible)
      const operatorToCable = new THREE.Mesh(
        new THREE.CylinderGeometry(0.15, 0.15, 0.8, 8),
        new THREE.MeshStandardMaterial({color: 0xffaa00, metalness: 0.9})
      );
      operatorToCable.position.set(7.8, TUNDISH_HEIGHT + 1, -9.8);
      operatorToCable.rotation.z = Math.PI/6;
      operatorToCable.castShadow = true;
      scene.add(operatorToCable);
      
      // OPERADOR/TRABAJADOR (figura humana M√ÅS GRANDE y VISIBLE)
      const operatorGroup = new THREE.Group();
      
      // Cuerpo (M√ÅS GRANDE)
      const operatorBody = new THREE.Mesh(
        new THREE.CylinderGeometry(1.2, 1.4, 5, 12),
        new THREE.MeshStandardMaterial({color: 0x0066cc, emissive: 0x003366, emissiveIntensity: 0.3}) // Overol azul brillante
      );
      operatorBody.position.y = 3.5;
      operatorBody.castShadow = true;
      operatorGroup.add(operatorBody);
      
      // Cabeza (M√ÅS GRANDE)
      const operatorHead = new THREE.Mesh(
        new THREE.SphereGeometry(1.1, 16, 16),
        new THREE.MeshStandardMaterial({color: 0xffcc99}) // Tono piel
      );
      operatorHead.position.y = 7;
      operatorHead.castShadow = true;
      operatorGroup.add(operatorHead);
      
      // Casco de seguridad AMARILLO BRILLANTE (M√ÅS GRANDE)
      const helmet = new THREE.Mesh(
        new THREE.SphereGeometry(1.2, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2),
        new THREE.MeshStandardMaterial({color: 0xffff00, metalness: 0.5, emissive: 0xaaaa00, emissiveIntensity: 0.5})
      );
      helmet.position.y = 7.5;
      helmet.castShadow = true;
      operatorGroup.add(helmet);
      
      // Brazo izquierdo (M√ÅS GRUESO)
      const leftArm = new THREE.Mesh(
        new THREE.CylinderGeometry(0.4, 0.4, 4, 12),
        new THREE.MeshStandardMaterial({color: 0x0066cc})
      );
      leftArm.position.set(-1.5, 4.5, 0);
      leftArm.rotation.z = -Math.PI/8;
      leftArm.castShadow = true;
      operatorGroup.add(leftArm);
      
      // Brazo derecho LEVANTADO jalando el cable (M√ÅS GRUESO)
      const rightArm = new THREE.Mesh(
        new THREE.CylinderGeometry(0.4, 0.4, 4, 12),
        new THREE.MeshStandardMaterial({color: 0x0066cc})
      );
      rightArm.position.set(0.5, 5, 0.2);
      rightArm.rotation.x = -Math.PI/6;
      rightArm.rotation.z = Math.PI/12;
      rightArm.castShadow = true;
      operatorGroup.add(rightArm);
      
      // Mano derecha GRANDE agarrando el cable (conectada visualmente)
      const rightHand = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 12, 12),
        new THREE.MeshStandardMaterial({color: 0xffcc99})
      );
      rightHand.position.set(0.3, 6.5, 0.5);
      rightHand.castShadow = true;
      operatorGroup.add(rightHand);
      
      // Antebrazo conectado a la manija
      const forearm = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35, 0.35, 2, 12),
        new THREE.MeshStandardMaterial({color: 0x0066cc})
      );
      forearm.position.set(-0.2, 7, 0.5);
      forearm.rotation.x = -Math.PI/12;
      forearm.rotation.z = Math.PI/6;
      forearm.castShadow = true;
      operatorGroup.add(forearm);
      
      // Pierna izquierda (M√ÅS GRUESA)
      const leftLeg = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.45, 4, 12),
        new THREE.MeshStandardMaterial({color: 0x003366})
      );
      leftLeg.position.set(-0.5, -1, 0);
      leftLeg.castShadow = true;
      operatorGroup.add(leftLeg);
      
      // Pierna derecha (M√ÅS GRUESA)
      const rightLeg = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.45, 4, 12),
        new THREE.MeshStandardMaterial({color: 0x003366})
      );
      rightLeg.position.set(0.5, -1, 0);
      rightLeg.castShadow = true;
      operatorGroup.add(rightLeg);
      
      // Botas GRANDES
      for(let x of [-0.5, 0.5]){
        const boot = new THREE.Mesh(
          new THREE.BoxGeometry(0.8, 0.5, 1.2),
          new THREE.MeshStandardMaterial({color: 0x222222, metalness: 0.5})
        );
        boot.position.set(x, -3.2, 0.2);
        boot.castShadow = true;
        operatorGroup.add(boot);
      }
      
      // PLATAFORMA SEGURA PARA EL OPERADOR (alejada del l√≠quido)
      const operatorPlatform = new THREE.Mesh(
        new THREE.BoxGeometry(8, 2, 8),
        new THREE.MeshStandardMaterial({color: 0x4a4a4a, metalness:0.7, roughness:0.5})
      );
      operatorPlatform.position.set(8, TUNDISH_HEIGHT - 2, -10);
      operatorPlatform.castShadow = true;
      operatorPlatform.receiveShadow = true;
      scene.add(operatorPlatform);
      
      // Vigas de soporte para la plataforma del operador
      for(let x of [5, 11]){
        for(let z of [-13, -7]){
          const beam = new THREE.Mesh(
            new THREE.BoxGeometry(2, TUNDISH_HEIGHT - 3, 2),
            new THREE.MeshStandardMaterial({color: 0x444444, metalness:0.8})
          );
          beam.position.set(x, (TUNDISH_HEIGHT - 3)/2, z);
          beam.castShadow = true;
          scene.add(beam);
        }
      }
      
      // Barandales de seguridad en la plataforma del operador
      const opRailMat = new THREE.MeshStandardMaterial({color: 0xffff00, metalness: 0.7});
      
      for(let x of [5, 8, 11]){
        for(let z of [-13, -7]){
          const post = new THREE.Mesh(
            new THREE.CylinderGeometry(0.15, 0.15, 3, 8),
            opRailMat
          );
          post.position.set(x, TUNDISH_HEIGHT, z);
          post.castShadow = true;
          scene.add(post);
        }
      }
      
      // Posicionar operador en su plataforma SEGURA
      operatorGroup.position.set(8, TUNDISH_HEIGHT, -10);
      operatorGroup.rotation.y = Math.PI/4; // Mirando hacia la polea
      scene.add(operatorGroup);
      
      // Guardar referencias para animaci√≥n
      window.operatorRightArm = rightArm;
      window.controlPulley = controlPulley;
      
      // L√çQUIDO FUNDIDO ROJO DENTRO (MUY VISIBLE) - OPTIMIZADO
      tundishPool=new THREE.Mesh(
        new THREE.CylinderGeometry(8.8,8.8,0.5,20), 
        new THREE.MeshStandardMaterial({
          color:0xff3300, 
          emissive:0xff4400, 
          emissiveIntensity:3.8, 
          transparent:false, 
          opacity:1
        })
      );
      tundishPool.position.set(0,TUNDISH_HEIGHT-2,0); 
      tundishPool.userData.elementType = 'tundish'; // Marcar para interacci√≥n
      scene.add(tundishPool);
      // Tornillos en tundish
      for(let a=0;a<8;a++){
        const ang=a/8*Math.PI*2;
        const bolt=new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,0.6,8), new THREE.MeshStandardMaterial({color:0x222222, metalness:0.9}));
        bolt.position.set(Math.cos(ang)*13.5,36,Math.sin(ang)*13.5); bolt.rotation.z=Math.PI/2; bolt.castShadow=true; scene.add(bolt);
      }

      // MOLD (molde de cobre) - DIRECTAMENTE DEBAJO DEL TUNDISH - COLOR CONVENCI√ìN: NARANJA #ff6600
      const MOLD_HEIGHT = 36; // Justo debajo del tundish (tundish est√° en 48)
      const moldOuter=new THREE.Mesh(new THREE.BoxGeometry(14,18,14), new THREE.MeshStandardMaterial({color:0xff6600, metalness:.7, roughness:.3, emissive:0xaa3300, emissiveIntensity:0.7}));
      moldOuter.position.set(0,MOLD_HEIGHT,0); moldOuter.castShadow=true; moldOuter.receiveShadow=true; 
      moldOuter.userData.elementType = 'mold'; // Marcar para interacci√≥n
      scene.add(moldOuter);
      
      // Abertura superior del molde (para ver c√≥mo entra el l√≠quido)
      const moldOpening=new THREE.Mesh(new THREE.CylinderGeometry(4,3,3,32), new THREE.MeshStandardMaterial({color:0xff8800, metalness:.8, roughness:.2, emissive:0xcc4400, emissiveIntensity:1}));
      moldOpening.position.set(0,MOLD_HEIGHT+9,0); moldOpening.castShadow=true; scene.add(moldOpening);
      
      // L√≠neas de refrigeraci√≥n (color enfriamiento azul claro)
      for(let i=0;i<4;i++){
        const pipe=new THREE.Mesh(new THREE.TorusGeometry(8,0.3,12,24,Math.PI), new THREE.MeshStandardMaterial({color:0x00aaff, emissive:0x0088cc, emissiveIntensity:0.4}));
        pipe.position.set(0,MOLD_HEIGHT-3+i*3,0); pipe.rotation.z=Math.PI/2; scene.add(pipe);
      }
      
      // PLATAFORMA PARA EL TRANSFORMADOR (separada del horno)
      const transformerPlatform = new THREE.Mesh(
        new THREE.BoxGeometry(18, 3, 15),
        new THREE.MeshStandardMaterial({color: 0x3a3a3a, metalness:0.7, roughness:0.5})
      );
      transformerPlatform.position.set(-78, 8, -15); // A un lado del horno, separado
      transformerPlatform.castShadow = true;
      transformerPlatform.receiveShadow = true;
      scene.add(transformerPlatform);
      
      // Vigas de soporte para la plataforma del transformador
      for(let x of [-85, -78, -71]){
        const beam = new THREE.Mesh(
          new THREE.BoxGeometry(2, 8, 2),
          new THREE.MeshStandardMaterial({color: 0x444444, metalness:0.8})
        );
        beam.position.set(x, 4, -20);
        beam.castShadow = true;
        scene.add(beam);
        
        const beam2 = new THREE.Mesh(
          new THREE.BoxGeometry(2, 8, 2),
          new THREE.MeshStandardMaterial({color: 0x444444, metalness:0.8})
        );
        beam2.position.set(x, 4, -10);
        beam2.castShadow = true;
        scene.add(beam2);
      }
      
      // TRANSFORMADOR visible - COLOR CONVENCI√ìN: AZUL #6688ff
      // Posicionado AL LADO del horno en su propia plataforma
      const transBox=new THREE.Mesh(new THREE.BoxGeometry(15,18,12), new THREE.MeshStandardMaterial({color:0x6688ff, metalness:0.6, roughness:0.5, emissive:0x3355aa, emissiveIntensity:0.4}));
      transBox.position.set(-78, 19, -15); // Sobre su propia plataforma, AL LADO del horno
      transBox.castShadow=true; transBox.receiveShadow=true; 
      transBox.userData.elementType = 'transformer'; // Marcar para interacci√≥n
      scene.add(transBox);
      // Bobinas del transformador (azul m√°s oscuro) - en la nueva posici√≥n
      for(let i=0;i<3;i++){
        const coil=new THREE.Mesh(new THREE.TorusGeometry(4,1.5,16,24), new THREE.MeshStandardMaterial({color:0x4466dd, metalness:0.8, emissive:0x2244aa, emissiveIntensity:0.3}));
        coil.position.set(-78, 13+i*6, -15); // Alineado con el transformador en su nueva posici√≥n
        coil.rotation.x=Math.PI/2; coil.castShadow=true; scene.add(coil);
      }
      // Aisladores en la nueva posici√≥n del transformador
      for(let i=0;i<4;i++){
        const insulator=new THREE.Mesh(new THREE.CylinderGeometry(0.8,1.2,4,12), new THREE.MeshStandardMaterial({color:0xaaccff, roughness:0.2}));
        insulator.position.set(-78+(i-1.5)*4, 29, -15); // Sobre el transformador en su nueva posici√≥n
        insulator.castShadow=true; scene.add(insulator);
      }
      
      // Cable el√©ctrico del transformador al horno (representaci√≥n visual)
      const powerCable=new THREE.Mesh(
        new THREE.BoxGeometry(15,1,1), 
        new THREE.MeshStandardMaterial({color:0x333333, metalness:0.8})
      );
      powerCable.position.set(-50,38,-5); powerCable.castShadow=true; scene.add(powerCable);
      
      // Estructura industrial: plataforma principal con sombras
      const platMat=new THREE.MeshStandardMaterial({color:0x3a4a5a, metalness:0.6, roughness:0.5});
      const plat1=new THREE.Mesh(new THREE.BoxGeometry(100,2,35), platMat);
      plat1.position.set(-10,46,0); plat1.castShadow=true; plat1.receiveShadow=true; scene.add(plat1);
      // Vigas de soporte bajo plataforma
      for(let x=-50;x<40;x+=15){
        const beam=new THREE.Mesh(new THREE.BoxGeometry(2,10,2), platMat);
        beam.position.set(x,41,15); beam.castShadow=true; scene.add(beam);
      }
      
      // Escalera amarilla detallada con barandillas
      const stairMat=new THREE.MeshStandardMaterial({color:0xffa500, metalness:0.4, roughness:0.5});
      for(let i=0;i<12;i++){
        const step=new THREE.Mesh(new THREE.BoxGeometry(3.5,0.5,10), stairMat);
        step.position.set(-52,8+i*3.2,0); step.castShadow=true; step.receiveShadow=true; scene.add(step);
      }
      // Barandillas dobles
      const rail1=new THREE.Mesh(new THREE.BoxGeometry(0.4,42,0.4), stairMat);
      rail1.position.set(-53.5,28,4.5); rail1.castShadow=true; scene.add(rail1);
      const rail2=new THREE.Mesh(new THREE.BoxGeometry(0.4,42,0.4), stairMat);
      rail2.position.set(-53.5,28,-4.5); rail2.castShadow=true; scene.add(rail2);
      // Travesa√±os horizontales
      for(let i=0;i<8;i++){
        const cross=new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,9), stairMat);
        cross.position.set(-53.5,12+i*4.5,0); scene.add(cross);
      }
      
      // Barandilla plataforma con postes y travesa√±os
      for(let x=-55;x<35;x+=6){
        const post=new THREE.Mesh(new THREE.BoxGeometry(0.4,4,0.4), stairMat);
        post.position.set(x,49,16); post.castShadow=true; scene.add(post);
        if(x<28){
          const rail=new THREE.Mesh(new THREE.BoxGeometry(6,0.3,0.3), stairMat);
          rail.position.set(x+3,50.5,16); scene.add(rail);
        }
      }
      
      // Piso/base industrial (como en la imagen)
      const floor1=new THREE.Mesh(new THREE.BoxGeometry(120,3,40), new THREE.MeshStandardMaterial({color:0x5a4a3a, roughness:0.9}));
      floor1.position.set(-10,6,0); floor1.receiveShadow=true; scene.add(floor1);
      const floor2=new THREE.Mesh(new THREE.BoxGeometry(100,3,40), new THREE.MeshStandardMaterial({color:0x4a3a2a, roughness:0.9}));
      floor2.position.set(30,-8,0); floor2.receiveShadow=true; scene.add(floor2);
      
      // PUENTE GR√öA (overhead crane) - EXTENDIDO hacia el √°rea del cuchar√≥n - COLOR CONVENCI√ìN: AMARILLO #ffdd00
      const CRANE_BEAM_HEIGHT = 85; // M√ÅS ALTO (antes 75)
      const CRANE_Z_POSITION = 2.5; // Centrado entre tundish (Z=0) y cuchar√≥n (Z=5)
      const craneMat=new THREE.MeshStandardMaterial({color:0xffdd00, metalness:0.7, roughness:0.3, emissive:0xaa8800, emissiveIntensity:0.4});
      // Viga principal (bridge beam) - EXTENDIDA y REPOSICIONADA
      const mainBeam=new THREE.Mesh(new THREE.BoxGeometry(120,3,6), craneMat);
      mainBeam.position.set(-10,CRANE_BEAM_HEIGHT,CRANE_Z_POSITION); mainBeam.castShadow=true; scene.add(mainBeam);
      
      // POLEA 1: En la viga principal (para movimiento del trolley)
      cranePulley1=new THREE.Mesh(new THREE.CylinderGeometry(2,2,1.5,24), new THREE.MeshStandardMaterial({color:0x333333, metalness:0.95, roughness:0.1}));
      cranePulley1.position.set(-10,CRANE_BEAM_HEIGHT+1.5,0); cranePulley1.rotation.x=Math.PI/2; cranePulley1.castShadow=true; scene.add(cranePulley1);
      // Ranuras de la polea 1
      for(let i=0;i<3;i++){
        const groove=new THREE.Mesh(new THREE.TorusGeometry(2.1,0.1,8,24), new THREE.MeshStandardMaterial({color:0x222222}));
        groove.position.set(-10,CRANE_BEAM_HEIGHT+1.5+(i-1)*0.4,0); groove.rotation.x=Math.PI/2; scene.add(groove);
      }
      
      // Vigas laterales de soporte - EXTENDIDAS hacia el √°rea del cuchar√≥n
      const sideBeam1=new THREE.Mesh(new THREE.BoxGeometry(4,4,50), craneMat);
      sideBeam1.position.set(-70,CRANE_BEAM_HEIGHT,10); sideBeam1.castShadow=true; scene.add(sideBeam1);
      const sideBeam2=new THREE.Mesh(new THREE.BoxGeometry(4,4,50), craneMat);
      sideBeam2.position.set(50,CRANE_BEAM_HEIGHT,10); sideBeam2.castShadow=true; scene.add(sideBeam2);
      
      // Columnas de soporte de la gr√∫a - M√ÅS ALTAS y extendidas
      for(let x of [-70,50]){
        for(let z of [-13, 0, 15, 28]){ // Distribuidas a lo largo incluyendo el √°rea del cuchar√≥n
          const col=new THREE.Mesh(new THREE.BoxGeometry(3,35,3), new THREE.MeshStandardMaterial({color:0x555555, metalness:0.8}));
          col.position.set(x,CRANE_BEAM_HEIGHT-17.5,z); col.castShadow=true; scene.add(col);
        }
      }
      
      // TROLLEY (Carro) - GRUPO ANIMABLE - M√ÅS ALTO
      craneTrolley=new THREE.Group();
      const trolleyBody=new THREE.Mesh(new THREE.BoxGeometry(8,4,6), new THREE.MeshStandardMaterial({color:0x3366aa, metalness:0.8, roughness:0.3}));
      trolleyBody.position.y=81; trolleyBody.castShadow=true; craneTrolley.add(trolleyBody);
      
      // POLEA 2: En el trolley (de donde cuelga el cable del gancho)
      cranePulley2=new THREE.Mesh(new THREE.CylinderGeometry(1.5,1.5,1.2,24), new THREE.MeshStandardMaterial({color:0x333333, metalness:0.95, roughness:0.1}));
      cranePulley2.position.y=79; cranePulley2.rotation.x=Math.PI/2; cranePulley2.castShadow=true; craneTrolley.add(cranePulley2);
      // Ranuras de la polea 2
      for(let i=0;i<3;i++){
        const groove=new THREE.Mesh(new THREE.TorusGeometry(1.6,0.08,8,24), new THREE.MeshStandardMaterial({color:0x222222}));
        groove.position.y=79+(i-1)*0.3; groove.rotation.x=Math.PI/2; craneTrolley.add(groove);
      }
      
      // Motor del trolley
      const motor=new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshStandardMaterial({color:0x555555, metalness:0.9}));
      motor.position.set(0,83,0); motor.castShadow=true; craneTrolley.add(motor);
      
      // POSICI√ìN INICIAL: Trolley empieza en posici√≥n intermedia
      craneTrolley.position.set(-40,0,5); // Z=5 cerca del cuchar√≥n (nueva posici√≥n m√°s cercana al horno)
      craneTrolley.userData.elementType = 'crane'; // Marcar para interacci√≥n
      scene.add(craneTrolley);
      
      // CABLE del gancho (actualizable din√°micamente) - M√ÅS ALTO
      craneHookCable=new THREE.Mesh(new THREE.CylinderGeometry(0.25,0.25,10,12), new THREE.MeshStandardMaterial({color:0x1a1a1a, metalness:0.9}));
      craneHookCable.position.set(-40,74,15); scene.add(craneHookCable);
      
      // GANCHO - GRUPO ANIMABLE - M√ÅS ALTO
      craneHook=new THREE.Group();
      const hookBlock=new THREE.Mesh(new THREE.BoxGeometry(2.5,2.5,2.5), new THREE.MeshStandardMaterial({color:0x888888, metalness:0.9, roughness:0.2}));
      hookBlock.castShadow=true; craneHook.add(hookBlock);
      
      const hookShape=new THREE.Mesh(new THREE.TorusGeometry(2,0.5,12,16,Math.PI), new THREE.MeshStandardMaterial({color:0x666666, metalness:0.9}));
      hookShape.position.y=-1.5; hookShape.rotation.x=Math.PI/2; hookShape.castShadow=true; craneHook.add(hookShape);
      
      // POSICI√ìN INICIAL: Gancho arriba
      craneHook.position.set(-40,75,5); // Z=5 cerca del cuchar√≥n (nueva posici√≥n m√°s cercana al horno)
      craneHook.userData.elementType = 'crane'; // Marcar para interacci√≥n
      scene.add(craneHook);
      
      // Luces de seguridad en la gr√∫a - M√ÅS ALTAS
      const craneLight1=new THREE.Mesh(new THREE.SphereGeometry(0.6,12,12), new THREE.MeshStandardMaterial({color:0xff0000, emissive:0xff0000, emissiveIntensity:2}));
      craneLight1.position.set(-70,CRANE_BEAM_HEIGHT+1.5,0); scene.add(craneLight1);
      const craneLight2=new THREE.Mesh(new THREE.SphereGeometry(0.6,12,12), new THREE.MeshStandardMaterial({color:0xff0000, emissive:0xff0000, emissiveIntensity:2}));
      craneLight2.position.set(50,CRANE_BEAM_HEIGHT+1.5,0); scene.add(craneLight2);
    }

    function buildCasterPath(){
      // Path: vertical down desde el molde elevado, CURVA MUCHO M√ÅS LARGA Y PRONUNCIADA
      const pts=[ 
        new THREE.Vector3(0,35,0),     // Sale del molde
        new THREE.Vector3(0,28,0),     // Baja vertical
        new THREE.Vector3(0,20,0),     // Contin√∫a vertical
        new THREE.Vector3(0,12,0),     // M√°s vertical
        new THREE.Vector3(0,5,0),      // Final parte vertical
        new THREE.Vector3(2,0,0),      // INICIO DE CURVA SUAVE
        new THREE.Vector3(5,-4,0),     // Curva progresiva
        new THREE.Vector3(10,-8,0),    // Mitad de curva
        new THREE.Vector3(18,-12,0),   // Contin√∫a curva
        new THREE.Vector3(28,-15,0),   // Casi horizontal
        new THREE.Vector3(40,-16,0),   // Ya horizontal
        new THREE.Vector3(60,-16,0),   // Contin√∫a horizontal
        new THREE.Vector3(90,-16,0),   // M√°s largo
        new THREE.Vector3(120,-16,0)   // Salida final
      ];
      path=new THREE.CatmullRomCurve3(pts);
      pathLen=path.getLength();
    }

    function buildRollersAndSprays(){
      // RODILLOS - COLOR CONVENCI√ìN: GRIS #888888
      const rMat=new THREE.MeshStandardMaterial({color:0x888888, metalness:0.9, roughness:0.3, emissive:0x444444, emissiveIntensity:0.2});
      // vertical rollers near the mold - M√ÅS DENSOS
      for(let y=33;y>=6;y-=4){ 
        const r=new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,10,12), rMat); 
        r.rotation.x=Math.PI/2; r.position.set(0,y,0); r.castShadow=true; r.receiveShadow=true; rollersV.push(r); scene.add(r);
      }
      // Rodillos en la ZONA DE CURVA EXTENDIDA (m√°s rodillos para la curva m√°s larga)
      const curveRollerPositions = [
        {x:0, y:5}, {x:1, y:2}, {x:3, y:-1}, {x:5, y:-4}, 
        {x:8, y:-7}, {x:12, y:-10}, {x:16, y:-12}, {x:20, y:-14},
        {x:25, y:-15}, {x:30, y:-15.5}
      ];
      curveRollerPositions.forEach(pos => {
        const r=new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,10,12), rMat);
        r.position.set(pos.x, pos.y, 0); 
        const angle = Math.atan2(pos.y, pos.x);
        r.rotation.z=angle + Math.PI/2; 
        r.castShadow=true; rollersV.push(r); scene.add(r);
      });
      // horizontal rollers along x - EXTENDIDOS para la mayor longitud
      for(let x=35;x<=120;x+=8){ 
        const r=new THREE.Mesh(new THREE.CylinderGeometry(1.8,1.8,10,12), rMat); 
        r.rotation.z=Math.PI/2; r.position.set(x,-16,0); r.castShadow=true; r.receiveShadow=true; rollersH.push(r); scene.add(r);
      }    

      // SPRAY RINGS - COLOR CONVENCI√ìN: AZUL CLARO #00aaff (enfriamiento)
      for(let y=18;y>=2;y-=4){
        const ring=new THREE.Mesh(new THREE.TorusGeometry(7, 0.6, 16, 32), new THREE.MeshStandardMaterial({color:0x00aaff, emissive:0x0088dd, emissiveIntensity:0.9, metalness:0.9}));
        ring.rotation.x=Math.PI/2; ring.position.set(0,y,0); ring.castShadow=true; scene.add(ring);
        sprays.push(ring);
        // Tuber√≠as de conexi√≥n (mismo color enfriamiento)
        for(let a=0;a<4;a++){
          const ang=a/4*Math.PI*2;
          const pipe=new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,3,12), new THREE.MeshStandardMaterial({color:0x0099ee, emissive:0x0077bb, emissiveIntensity:0.3}));
          pipe.position.set(Math.cos(ang)*8,y,Math.sin(ang)*8); pipe.rotation.z=Math.PI/2; scene.add(pipe);
        }
      }
      
      // Marco estructural vertical
      const frameMat=new THREE.MeshStandardMaterial({color:0x2a3a4a, metalness:0.7, roughness:0.4});
      for(let z=-8;z<=8;z+=16){
        const beam=new THREE.Mesh(new THREE.BoxGeometry(2,40,2), frameMat);
        beam.position.set(0,10,z); beam.castShadow=true; scene.add(beam);
      }
    }

    function buildStrand(){
      // Palanquilla M√ÅS GRANDE y M√ÅS BRILLANTE para verla mejor
      const mat=new THREE.MeshStandardMaterial({color:0xff5533, emissive:0xff3300, emissiveIntensity:2.5, metalness:0.8, roughness:0.2});
      strand=new THREE.Mesh(new THREE.BoxGeometry(7,10,7), mat); 
      strand.castShadow=true; strand.receiveShadow=true;
      scene.add(strand); u=0; t=0;
    }

    function animate(){ 
      requestAnimationFrame(animate); 
      if(isRunning){ 
        t+=0.016; 
        update(); 
      } 
      if(renderer && scene && camera){
        renderer.render(scene,camera); 
      }
    }

    function update(){
      try {
      // advance along path
        if(!path || !strand) return;
        
        u = (u + params.speed) % 1; 
        const pt=path.getPointAt(u), tg=path.getTangentAt(u);
      strand.position.copy(pt);
        const axis=new THREE.Vector3(); 
        axis.crossVectors(new THREE.Vector3(0,1,0), tg).normalize();
      const angle=Math.acos(new THREE.Vector3(0,1,0).dot(tg));
      strand.setRotationFromAxisAngle(axis, angle);
      // cooling
      const cool=u; const hot=1-cool; const emiss=0.2+1.2*hot; strand.material.emissiveIntensity=emiss; strand.material.color.setHSL(0.03+0.06*hot,1,0.45);
      const temp=Math.round(200+1000*hot); 
      document.getElementById('tempValue').textContent=temp+"¬∞C"; 
      // Actualizar tambi√©n en el modal
      const modalTemp = document.getElementById('tempValueModal');
      const modalBar = document.getElementById('tempBarModal');
      if(modalTemp) modalTemp.textContent=temp+"¬∞C";
      if(modalBar) modalBar.style.width=(temp/1200*100)+"%";
      // sprays flicker - SIMPLIFICADO
      if(t%2<0.1){ // Solo actualizar cada 2 segundos
        sprays.forEach(s=>{ s.material.emissiveIntensity = 0.8; });
      }
      // Ciclo completo m√°s largo para incluir el vertido del horno
      const fullCycle = (t*0.03) % 1; // M√°s lento para ver todos los movimientos
      
      // ANIMACI√ìN COMPLETA: HORNO ‚Üí LADLE (FIJO) ‚Üí GR√öA RECOGE ‚Üí TRANSPORTA ‚Üí VIERTE ‚Üí REGRESA
      if(craneTrolley && craneHook && ladle){
        
        let trolleyX, trolleyZ, hookY, ladlePosX, ladlePosY, ladlePosZ, pourAngle, furnaceTilt;
        const LADLE_HOME_X = -78; // A LA IZQUIERDA del horno, no encima
        const LADLE_HOME_Y = 4; // Nivel bajo
        const LADLE_HOME_Z = 5; // Desplazado en Z para buena ca√≠da
        
        // FASE 0: Horno vierte en cuchar√≥n (0% - 15%)
        if(fullCycle < 0.15){
          const progress = fullCycle / 0.15;
          
          // LADLE PERMANECE FIJO en su base
          ladlePosX = LADLE_HOME_X;
          ladlePosY = LADLE_HOME_Y;
          ladlePosZ = LADLE_HOME_Z;
          pourAngle = 0;
          
          // Gr√∫a permanece arriba
          trolleyX = -40;
          trolleyZ = 5; // Nueva posici√≥n Z del cuchar√≥n
          hookY = 75;
          
          // Horno se bascula
          if(progress < 0.3){
            furnaceTilt = 0;
          } else if(progress < 0.7){
            const tiltProgress = (progress - 0.3) / 0.4;
            furnaceTilt = tiltProgress * 0.4;
          } else {
            const returnProgress = (progress - 0.7) / 0.3;
            furnaceTilt = 0.4 * (1 - returnProgress);
          }
        }
        // FASE 1: Gr√∫a se mueve hacia el ladle y baja (15% - 30%)
        else if(fullCycle < 0.3){
          const progress = (fullCycle - 0.15) / 0.15;
          
          // LADLE PERMANECE FIJO
          ladlePosX = LADLE_HOME_X;
          ladlePosY = LADLE_HOME_Y;
          ladlePosZ = LADLE_HOME_Z;
          pourAngle = 0;
          
          // Gr√∫a se mueve SOLO en X hacia el ladle, y baja
          trolleyX = -40 + progress * (-38); // De -40 a -78 (cuchar√≥n a la izquierda del horno)
          trolleyZ = 5; // FIJO en Z=5 (donde est√° el cuchar√≥n)
          hookY = 75 - progress * 66; // Baja de 75 a 9 (engancha ladle)
          
          furnaceTilt = 0;
        }
        // FASE 2: Gr√∫a levanta el ladle (30% - 45%)
        else if(fullCycle < 0.45){
          const progress = (fullCycle - 0.3) / 0.15;
          
          // Gr√∫a levanta (posici√≥n X,Z fija, solo sube Y)
          trolleyX = -78; // Cuchar√≥n a la izquierda del horno
          trolleyZ = 5; // FIJO en Z=5
          hookY = 9 + progress * 61; // Sube de 9 a 70
          
          // LADLE empieza a seguir al gancho
          ladlePosX = LADLE_HOME_X;
          ladlePosY = hookY - 5;
          ladlePosZ = LADLE_HOME_Z;
          pourAngle = 0;
          
          furnaceTilt = 0;
        }
        // FASE 3: Gr√∫a transporta ladle al tundish (45% - 60%)
        else if(fullCycle < 0.6){
          const progress = (fullCycle - 0.45) / 0.15;
          
          // Gr√∫a se mueve en X hacia el tundish y ajusta Z
          trolleyX = -78 + progress * 75; // De -78 a -3 (transporta desde la izquierda)
          trolleyZ = 5 + progress * (-5); // De 5 a 0 (se mueve hacia adelante)
          hookY = 70; // Altura constante
          
          // Ladle sigue al gancho
          ladlePosX = trolleyX;
          ladlePosY = hookY - 5;
          ladlePosZ = trolleyZ;
          pourAngle = 0;
          
          furnaceTilt = 0;
        }
        // FASE 4: Ladle vierte en tundish (60% - 75%)
        else if(fullCycle < 0.75){
          const progress = (fullCycle - 0.6) / 0.15;
          
          // Gr√∫a fija sobre tundish
          trolleyX = -3;
          trolleyZ = 0;
          hookY = 70;
          
          // Ladle se inclina para verter
          ladlePosX = trolleyX;
          ladlePosY = hookY - 5;
          ladlePosZ = trolleyZ;
          pourAngle = -progress * 1.4; // Se inclina progresivamente
          
          furnaceTilt = 0;
        }
        // FASE 5: Gr√∫a regresa ladle a posici√≥n inicial (75% - 100%)
        else{
          const progress = (fullCycle - 0.75) / 0.25;
          
          furnaceTilt = 0;
          
          // Subfase 5a: Enderezar ladle (75% - 80%)
          if(progress < 0.2){
            const subProgress = progress / 0.2;
            trolleyX = -3;
            trolleyZ = 0;
            hookY = 70;
            
            ladlePosX = trolleyX;
            ladlePosY = hookY - 5;
            ladlePosZ = trolleyZ;
            pourAngle = -1.4 + subProgress * 1.4; // Endereza de -1.4 a 0
          }
          // Subfase 5b: Mover en X y Z hacia la base del cuchar√≥n (80% - 90%)
          else if(progress < 0.6){
            const subProgress = (progress - 0.2) / 0.4;
            trolleyX = -3 + subProgress * (-75); // De -3 a -78 (regresa a la izquierda del horno)
            trolleyZ = 0 + subProgress * 5; // De 0 a 5 (nueva posici√≥n del cuchar√≥n)
            hookY = 70; // Mantiene altura
            
            ladlePosX = trolleyX;
            ladlePosY = hookY - 5;
            ladlePosZ = trolleyZ;
            pourAngle = 0;
          }
          // Subfase 5c: Bajar y soltar el cuchar√≥n en su base (90% - 100%)
          else{
            const subProgress = (progress - 0.6) / 0.4;
            trolleyX = -78; // Cuchar√≥n a la izquierda del horno
            trolleyZ = 5; // Nueva posici√≥n del cuchar√≥n
            hookY = 70 - subProgress * 61; // Baja de 70 a 9
            
            // Durante la bajada, el ladle sigue al gancho
            if(subProgress < 0.8){
              ladlePosX = trolleyX;
              ladlePosY = hookY - 5;
              ladlePosZ = trolleyZ;
              pourAngle = 0;
            } else {
              // Al final, el ladle se posa en su base
              ladlePosX = LADLE_HOME_X;
              ladlePosY = LADLE_HOME_Y;
              ladlePosZ = LADLE_HOME_Z;
              pourAngle = 0;
            }
          }
        }
        
        // Aplicar rotaci√≥n al horno
        if(furnaceGroup){
          furnaceGroup.rotation.z = furnaceTilt;
        }
        
        // Aplicar posiciones a la gr√∫a
        craneTrolley.position.x = trolleyX;
        craneTrolley.position.z = trolleyZ;
        craneHook.position.x = trolleyX;
        craneHook.position.y = hookY;
        craneHook.position.z = trolleyZ;
        
        // Actualizar cable del gancho
        if(craneHookCable){
          const cableLength = 81 - hookY;
          craneHookCable.scale.y = cableLength/10;
          craneHookCable.position.x = trolleyX;
          craneHookCable.position.y = hookY + cableLength/2;
          craneHookCable.position.z = trolleyZ;
        }
        
        // Aplicar posici√≥n al ladle
        ladle.position.x = ladlePosX;
        ladle.position.y = ladlePosY;
        ladle.position.z = ladlePosZ;
        ladle.rotation.z = pourAngle;
        
        // Rotaci√≥n de las poleas
        if(cranePulley1) cranePulley1.rotation.y = t*2;
        if(cranePulley2) cranePulley2.rotation.y = t*2;
        
        // Variable global para saber si est√° vertiendo (usada por part√≠culas) - FASE 4
        window.isPouring = (fullCycle >= 0.6 && fullCycle < 0.75); // Durante la fase de vertido
        
        // ANIMACI√ìN DEL OPERADOR Y LA POLEA durante el vertido
        if(window.operatorRightArm && window.controlPulley){
          if(window.isPouring){
            // Durante el vertido: operador jala el cable (animaci√≥n m√°s visible)
            const pullProgress = (fullCycle - 0.6) / 0.15;
            // Movimiento de jalar el cable - arriba y abajo
            window.operatorRightArm.rotation.x = -Math.PI/6 + Math.sin(pullProgress * Math.PI * 8) * 0.4;
            window.operatorRightArm.rotation.z = Math.PI/12 + Math.sin(pullProgress * Math.PI * 8) * 0.2;
            // La polea gira visiblemente
            window.controlPulley.rotation.x = t * 3;
          } else {
            // Fuera del vertido: brazo en posici√≥n de reposo
            window.operatorRightArm.rotation.x = -Math.PI/6;
            window.operatorRightArm.rotation.z = Math.PI/12;
          }
        }
      }
      
      // Actualizar visibilidad y posici√≥n del chorro de fundido - CA√çDA LARGA Y VISIBLE
      if(molten && ladle){
        // Solo mostrar el chorro cuando est√° vertiendo
        molten.visible = window.isPouring || false;
        if(window.isPouring){
          const ladleX = ladle.position.x;
          const ladleY = ladle.position.y;
          const ladleAngle = ladle.rotation.z;
          // Calcular posici√≥n del PICO FRONTAL del ladle (posici√≥n relativa 6,3 rotada)
          const spoutLocalX = 6, spoutLocalY = 3;
          const mouthX = ladleX + Math.cos(ladleAngle) * spoutLocalX - Math.sin(ladleAngle) * spoutLocalY;
          const mouthY = ladleY + Math.sin(ladleAngle) * spoutLocalX + Math.cos(ladleAngle) * spoutLocalY;
          // Posicionar el chorro desde el pico frontal hasta el tundish
          molten.position.x = (mouthX + 0)/2; // Centro entre pico y tundish
          molten.position.y = (mouthY + 50)/2; // Centro vertical
          molten.rotation.z = ladleAngle * 0.4; // M√°s seguimiento del √°ngulo
          molten.material.emissiveIntensity = 5 + 1.2*Math.sin(t*4); // M√ÅS BRILLANTE
        }
      }
      
      // Animaci√≥n del pool del tundish - SIMPLIFICADA para mejor rendimiento
      if(tundishPool){
        // Posici√≥n fija (nivel constante)
        tundishPool.position.y=49.5;
        // Escala fija
        tundishPool.scale.set(1, 10, 1);
        // Solo brillo pulsante (sin rotaci√≥n ni escala din√°mica)
        tundishPool.material.emissiveIntensity=3.8+0.6*Math.sin(t*2);
      }
      
      // GOTAS DEL HORNO AL LADLE - Sistema de part√≠culas mejorado
      // Solo vierte cuando el horno est√° INCLINADO (despu√©s del 30% de la FASE 0)
      const furnacePhaseProgress = fullCycle / 0.15; // Progreso dentro de FASE 0
      const isFurnacePouring = (fullCycle >= 0.045 && fullCycle < 0.105) && furnacePhaseProgress >= 0.3 && furnacePhaseProgress < 0.7; // Solo cuando est√° inclinado
      
      if(isFurnacePouring && furnaceGroup){
        // Crear m√°s gotas del horno para flujo continuo (similar al ladle)
        if(furnaceParticles.length === 0){
          for(let i=0; i<12; i++){
            const droplet = new THREE.Mesh(
              new THREE.CylinderGeometry(0.5, 0.7, 2.5, 8),
              new THREE.MeshStandardMaterial({color:0xff3300, emissive:0xff5500, emissiveIntensity:7})
            );
            droplet.castShadow = true;
            droplet.fallProgress = i * 0.083; // M√°s gotas, m√°s desfasadas
            furnaceParticles.push(droplet);
            scene.add(droplet);
          }
        }
        
        // Animar gotas del horno - desde el PICO VERTEDOR lateral IZQUIERDO hasta el cuchar√≥n
        // El furnaceGroup rota en Z, y el pico est√° en (-15, 8, 0) relativa al grupo
        // El grupo est√° en (-60, 19.5, 0)
        // Cuando rota, el pico se mueve siguiendo la rotaci√≥n
        const furnaceBaseX = -60;
        const furnaceBaseY = 19.5;
        const spoutOffsetX = -15; // El pico est√° 15 unidades a la IZQUIERDA
        const spoutOffsetY = 8; // El pico est√° 8 unidades arriba
        
        // Calcular posici√≥n del pico del horno con la rotaci√≥n aplicada
        // Rotaci√≥n en Z: x' = x*cos - y*sin, y' = x*sin + y*cos
        const rotZ = furnaceGroup.rotation.z;
        const furnaceMouthX = furnaceBaseX + (spoutOffsetX * Math.cos(rotZ) - spoutOffsetY * Math.sin(rotZ));
        const furnaceMouthY = furnaceBaseY + (spoutOffsetX * Math.sin(rotZ) + spoutOffsetY * Math.cos(rotZ));
        const furnaceMouthZ = 0;
        const ladleReceiveX = -78; // Cuchar√≥n a la IZQUIERDA del horno, no encima
        const ladleReceiveY = 9; // Altura del borde del cuchar√≥n en su base
        const ladleReceiveZ = 5; // Z del cuchar√≥n para buena ca√≠da
        
        furnaceParticles.forEach(droplet => {
          droplet.fallProgress += 0.04; // Velocidad moderada
          if(droplet.fallProgress >= 1){
            droplet.fallProgress = 0;
          }
          
          const progress = droplet.fallProgress;
          // Trayectoria PARAB√ìLICA M√ÅS NATURAL con gravedad
          droplet.position.x = furnaceMouthX * (1-progress) + ladleReceiveX * progress;
          droplet.position.y = furnaceMouthY * (1-progress) + ladleReceiveY * progress - Math.pow(progress, 2) * 5; // Ca√≠da cuadr√°tica natural
          droplet.position.z = furnaceMouthZ * (1-progress) + ladleReceiveZ * progress;
          
          // Rotar la gota para simular ca√≠da
          droplet.rotation.z = progress * Math.PI * 2;
          droplet.visible = true;
        });
      } else {
        furnaceParticles.forEach(p => p.visible = false);
      }
      
      // FLUJO DE L√çQUIDO ladle ‚Üí tundish - Cilindros delgados como gotas alargadas (3 gotas reciclables)
      if(window.isPouring && ladle){
        // Crear 3 gotas alargadas si no existen
        if(particles.length === 0){
          for(let i=0; i<3; i++){
            const droplet = new THREE.Mesh(
              new THREE.CylinderGeometry(0.4, 0.6, 2, 8), // Cilindro alargado (gota)
              new THREE.MeshStandardMaterial({color:0xff3300, emissive:0xff5500, emissiveIntensity:4})
            );
            droplet.castShadow = false;
            droplet.fallProgress = i * 0.33; // Desfasadas
            particles.push(droplet);
            scene.add(droplet);
          }
        }
        
        // Animar las 3 gotas (flujo continuo)
        const ladleX = ladle.position.x;
        const ladleY = ladle.position.y;
        const ladleAngle = ladle.rotation.z;
        // Calcular posici√≥n del PICO FRONTAL del ladle
        const spoutLocalX = 6, spoutLocalY = 3;
        const mouthX = ladleX + Math.cos(ladleAngle) * spoutLocalX - Math.sin(ladleAngle) * spoutLocalY;
        const mouthY = ladleY + Math.sin(ladleAngle) * spoutLocalX + Math.cos(ladleAngle) * spoutLocalY;
        
        particles.forEach(droplet => {
          // Ciclo de ca√≠da: reset cuando llega al tundish
          droplet.fallProgress += 0.04; // Velocidad de ca√≠da
          
          if(droplet.fallProgress >= 1){
            droplet.fallProgress = 0; // Reset para ca√≠da continua
          }
          
          // Interpolar posici√≥n (de ladle a tundish)
          const progress = droplet.fallProgress;
          droplet.position.x = mouthX * (1-progress) + 0 * progress;
          droplet.position.y = mouthY * (1-progress) + 49 * progress;
          droplet.position.z = 0;
          
          // Orientar el cilindro hacia abajo (vertical)
          droplet.rotation.x = 0;
          droplet.rotation.z = 0;
          
          droplet.visible = true;
        });
      } else {
        // Ocultar cuando no est√° vertiendo
        particles.forEach(p => p.visible = false);
      }
      } catch(error) {
        console.error('Error en update():', error);
      }
    }

    function bindUI(){
      document.getElementById('btnPlay').onclick=()=>{ isRunning=true; };
      document.getElementById('btnPause').onclick=()=>{ isRunning=false; };
      document.getElementById('btnReset').onclick=()=>{ isRunning=false; u=0; t=0; };
      document.getElementById('btnIso').onclick=()=>{ camera.position.set(80,45,110); camera.lookAt(0,10,0); };
      document.getElementById('btnTop').onclick=()=>{ camera.position.set(0,160,0.01); camera.lookAt(0,0,0); };
    }

    function onResize(){ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }
  </script>
</body>
</html>

